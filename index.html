<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Финансовый Планер — прототип</title>
  <style>
    :root{
      --bg:#0f1220;
      --card:#171b2e;
      --muted:#8e97b3;
      --text:#e8ecff;
      --accent:#6dd3fb;
      --accent2:#22d3ee;
      --warn:#ff8a8a;
      --ok:#86efac;
      --line1:#7aa2ff;
      --line2:#ffb86b;
      --line3:#4ade80;
      --grid:#2a3050;
      --purple:#a78bfa;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family:Inter, system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 600px at 20% -10%, #1a1f37 0%, #0f1220 60%) no-repeat fixed, var(--bg);
      color:var(--text);
      line-height:1.5;
    }
    #app{
      max-width:1200px;
      margin:32px auto 80px;
      padding:0 16px;
    }
    h1{margin:0 0 18px;font-weight:800;letter-spacing:.2px}
    .sub{color:var(--muted); margin-bottom:24px}
    .grid{
      display:grid;
      gap:16px;
    }
    @media (min-width: 980px){
      .grid{
        grid-template-columns: 1.1fr 1fr;
        align-items:start;
      }
    }
    section{
      background:linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.0));
      border:1px solid #242a47;
      border-radius:16px;
      padding:18px;
      box-shadow: 0 10px 30px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.05);
    }
    section h2{
      margin:0 0 12px;
      font-size:18px;
      letter-spacing:.2px;
    }
    .row{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:12px;
    }
    .field{
      display:flex;
      flex-direction:column;
      gap:6px;
      margin-bottom:10px;
    }
    label{
      font-size:13px;
      color:var(--muted);
    }
    input, button, select{
      background:#0f1326;
      color:var(--text);
      border:1px solid #283158;
      border-radius:10px;
      padding:10px 12px;
      font-size:14px;
      outline:none;
      transition:.15s border-color ease;
    }
    input:focus, select:focus{border-color:#3f5bd6}
    input[type="date"]{padding:9px 10px}
    .actions{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      margin-top:6px;
    }
    .btn{
      background:linear-gradient(180deg, #3f5bd6, #334ec0);
      border:none;
      padding:10px 14px;
      font-weight:600;
      cursor:pointer;
      transition: transform 0.1s;
    }
    .btn:hover{transform:translateY(-1px)}
    .btn:active{transform:translateY(0)}
    .btn.ghost{
      background:transparent;
      border:1px solid #334ec0;
    }
    .btn.accent{
      background:linear-gradient(180deg, var(--accent), var(--accent2));
      color:#0f1220;
    }
    .btn.small{
      padding:6px 10px;
      font-size:13px;
    }
    .btn.icon{
      padding:8px;
      min-width:36px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
    }
    .btn.danger{
      background:linear-gradient(180deg, #dc2626, #b91c1c);
    }
    .note{
      font-size:13px;
      color:var(--muted);
    }
    .kpi{
      display:grid;
      grid-template-columns: repeat(2, minmax(0,1fr));
      gap:12px;
      margin:8px 0 4px;
    }
    @media (min-width:680px){
      .kpi{grid-template-columns: repeat(4, minmax(0,1fr));}
    }
    .tile{
      background: #0f1326;
      border:1px solid #27305a;
      border-radius:12px;
      padding:12px;
      position:relative;
      overflow:hidden;
    }
    .tile.highlight{
      background: linear-gradient(135deg, rgba(167,139,250,.06), rgba(109,211,251,.06));
      border-color:#4338ca;
    }
    .tile .label{font-size:12px;color:var(--muted)}
    .tile .value{font-size:18px;font-weight:700;margin-top:4px}
    .tile.warn{border-color:#4e1e2a;background:rgba(255,72,72,.06)}
    .tile.ok{border-color:#2d4a38;background:rgba(61, 194, 124, .06)}
    .warn-text{color:var(--warn); font-weight:600}
    .ok-text{color:var(--ok); font-weight:600}
    .divider{height:1px;background:#27305a;margin:14px 0}
    #chartWrap{
      background:#0d1122;
      border:1px solid #27305a;
      border-radius:12px;
      padding:10px;
    }
    canvas{width:100%; height:320px; display:block}
    .months{
      display:flex; flex-direction:column; gap:10px; margin-top:8px;
    }
    .month{
      background:#0f1326;
      border:1px solid #27305a;
      border-radius:12px;
      padding:12px;
      position:relative;
    }
    .month.current{
      border-color:#4338ca;
      background: linear-gradient(135deg, rgba(167,139,250,.03), rgba(109,211,251,.03));
    }
    .month-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:10px;
    }
    .month-name{
      font-weight:600;
      font-size:15px;
    }
    .month-stats{
      display:grid;
      grid-template-columns: repeat(3, 1fr);
      gap:8px;
      margin-bottom:10px;
    }
    .stat-item{
      background:#0b0f1e;
      border:1px solid #1f2937;
      border-radius:8px;
      padding:8px;
      text-align:center;
    }
    .stat-label{
      font-size:11px;
      color:var(--muted);
      margin-bottom:2px;
    }
    .stat-value{
      font-size:14px;
      font-weight:600;
    }
    .month-actions{
      display:flex;
      gap:8px;
      margin-top:10px;
    }
    .transactions{
      margin-top:10px;
      max-height:200px;
      overflow-y:auto;
    }
    .transaction{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding:6px 8px;
      background:#0b0f1e;
      border:1px solid #1f2937;
      border-radius:6px;
      margin-bottom:4px;
      font-size:13px;
    }
    .transaction .amount{
      font-weight:600;
      color:var(--warn);
    }
    .transaction .date{
      color:var(--muted);
      font-size:11px;
    }
    .pill{
      display:inline-flex; align-items:center; gap:8px;
      border:1px solid #27305a; padding:6px 10px; border-radius:999px; 
      font-size:12px; color:var(--muted);
    }
    .pill.accent{
      background:rgba(109,211,251,.1);
      border-color:var(--accent);
      color:var(--accent);
    }
    .legend{display:flex; gap:10px; flex-wrap:wrap; margin:8px 0 0}
    .dot{width:10px;height:10px;border-radius:50%}
    .dot.plan{background:var(--line1)}
    .dot.actual{background:var(--line2)}
    .dot.forecast{background:var(--line3)}
    .footer-note{margin-top:14px; font-size:12px; color:var(--muted)}
    .right{justify-self:end}
    .small{font-size:12px;color:var(--muted)}
    .hidden{display:none !important}
    
    /* Modal */
    .modal{
      position:fixed;
      top:0;
      left:0;
      right:0;
      bottom:0;
      background:rgba(0,0,0,.8);
      display:flex;
      align-items:center;
      justify-content:center;
      z-index:1000;
      padding:20px;
      opacity:0;
      visibility:hidden;
      transition: opacity 0.2s, visibility 0.2s;
    }
    .modal.show{
      opacity:1;
      visibility:visible;
    }
    .modal-content{
      background:var(--card);
      border:1px solid #27305a;
      border-radius:16px;
      padding:24px;
      max-width:500px;
      width:100%;
      max-height:80vh;
      overflow-y:auto;
      box-shadow: 0 20px 60px rgba(0,0,0,.5);
    }
    .modal-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:16px;
    }
    .modal-title{
      font-size:18px;
      font-weight:700;
    }
    .modal-close{
      background:transparent;
      border:none;
      color:var(--muted);
      font-size:20px;
      cursor:pointer;
      padding:0;
      width:28px;
      height:28px;
    }
    .modal-close:hover{color:var(--text)}
    
    /* Mandatory Payments */
    .mandatory-section{
      background:#0f1326;
      border:1px solid #27305a;
      border-radius:12px;
      padding:14px;
      margin-bottom:14px;
    }
    .mandatory-header{
      display:flex;
      justify-content:space-between;
      align-items:center;
      margin-bottom:12px;
    }
    .mandatory-title{
      font-size:15px;
      font-weight:600;
    }
    .mandatory-list{
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .mandatory-item{
      background:#0b0f1e;
      border:1px solid #1f2937;
      border-radius:8px;
      padding:10px;
      display:flex;
      justify-content:space-between;
      align-items:center;
    }
    .mandatory-info{
      flex:1;
    }
    .mandatory-name{
      font-size:14px;
      font-weight:500;
      margin-bottom:2px;
    }
    .mandatory-details{
      font-size:12px;
      color:var(--muted);
    }
    .mandatory-amount{
      font-size:16px;
      font-weight:700;
      color:var(--purple);
      margin-right:10px;
    }
    
    /* Recommendations */
    .recommendations{
      background: linear-gradient(135deg, rgba(167,139,250,.08), rgba(109,211,251,.08));
      border:1px solid #4338ca;
      border-radius:12px;
      padding:14px;
      margin-top:12px;
    }
    .rec-title{
      font-size:14px;
      font-weight:600;
      margin-bottom:10px;
      color:var(--purple);
    }
    .rec-grid{
      display:grid;
      grid-template-columns: repeat(2,1fr);
      gap:10px;
    }
    @media (min-width:600px){
      .rec-grid{grid-template-columns: repeat(3,1fr);}
    }
    .rec-item{
      background:#0f1326;
      border:1px solid #27305a;
      border-radius:8px;
      padding:10px;
      text-align:center;
    }
    .rec-label{
      font-size:11px;
      color:var(--muted);
      margin-bottom:4px;
    }
    .rec-value{
      font-size:16px;
      font-weight:700;
      color:var(--accent);
    }
    
    .badge{
      background:var(--accent);
      color:#0f1220;
      padding:2px 6px;
      border-radius:4px;
      font-size:10px;
      font-weight:700;
      margin-left:6px;
    }
    
    .input-group{
      display:flex;
      gap:8px;
      align-items:flex-end;
    }
    .input-group .field{
      flex:1;
    }
    .input-group .btn{
      margin-bottom:10px;
    }

        /* Стили для детального просмотра месяца */
    .month{
      cursor: pointer;
      transition: transform 0.1s, box-shadow 0.1s;
    }
    .month:hover{
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(0,0,0,.3);
    }
    
    #monthDetailModal .modal-content{
      max-width: 600px;
    }
    
    .month-detail-header{
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 20px;
    }
    
    .month-detail-title{
      font-size: 20px;
      font-weight: 700;
    }
    
    .pie-chart-container{
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 20px 0;
      position: relative;
    }
    
    #pieChart{
      max-width: 280px;
      max-height: 280px;
    }
    
    .chart-legend{
      display: flex;
      flex-direction: column;
      gap: 8px;
      margin-top: 16px;
    }
    
    .legend-item{
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
    }
    
    .legend-color{
      width: 16px;
      height: 16px;
      border-radius: 3px;
    }
    
    .detail-stats{
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 12px;
      margin-top: 20px;
    }
    
    .detail-stat{
      background: #0f1326;
      border: 1px solid #27305a;
      border-radius: 10px;
      padding: 12px;
    }
    
    .detail-stat-label{
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 4px;
    }
    
    .detail-stat-value{
      font-size: 18px;
      font-weight: 700;
    }
    
    .overspent{
      color: #ff4444;
    }

    /* Стили для сворачивания месяцев */
    .month-toggle-btn {
      background: transparent;
      border: 1px solid #27305a;
      color: var(--muted);
      width: 24px;
      height: 24px;
      border-radius: 6px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.2s;
      font-size: 12px;
      margin-left: 8px;
    }
    
    .month-toggle-btn:hover {
      background: rgba(109,211,251,.1);
      border-color: var(--accent);
      color: var(--accent);
    }
    
    .month.collapsed .month-content {
      display: none;
    }
    
    .month.collapsed {
      padding: 10px 12px;
    }
    
    .month.collapsed .month-header {
      margin-bottom: 0;
    }
    
    .month-toggle-btn.collapsed {
      transform: rotate(-90deg);
    }
    /* Стили для индикации средней траты */
.daily-avg-good {
  background: linear-gradient(135deg, rgba(134,239,172,.12), rgba(74,222,128,.12)) !important;
  border-color: #4ade80 !important;
}

.daily-avg-normal {
  background: linear-gradient(135deg, rgba(109,211,251,.08), rgba(167,139,250,.08)) !important;
  border-color: #4338ca !important;
}

.daily-avg-bad {
  background: linear-gradient(135deg, rgba(255,138,138,.12), rgba(255,68,68,.12)) !important;
  border-color: #ff4444 !important;
}

.daily-avg-value.good {
  color: #4ade80 !important;
}

.daily-avg-value.bad {
  color: #ff8a8a !important;
}

.progress-indicator {
  display: inline-block;
  margin-left: 8px;
  padding: 2px 8px;
  border-radius: 12px;
  font-size: 11px;
  font-weight: 700;
}

.progress-indicator.good {
  background: rgba(134,239,172,.2);
  color: #4ade80;
}

.progress-indicator.normal {
  background: rgba(109,211,251,.2);
  color: var(--accent);
}

.progress-indicator.bad {
  background: rgba(255,138,138,.2);
  color: #ff8a8a;
}

    /* Стили для прогноза на основе истории */
.dot.trend{background:#ff6b6b}
.legend-item{
  position: relative;
}
.legend-item .info-icon{
  display: inline-block;
  width: 14px;
  height: 14px;
  border-radius: 50%;
  background: rgba(109,211,251,.2);
  color: var(--accent);
  font-size: 10px;
  line-height: 14px;
  text-align: center;
  margin-left: 4px;
  cursor: help;
}
.legend-item .tooltip{
  position: absolute;
  bottom: 100%;
  left: 0;
  background: var(--card);
  border: 1px solid #27305a;
  border-radius: 8px;
  padding: 8px 12px;
  font-size: 12px;
  color: var(--text);
  white-space: nowrap;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.2s, visibility 0.2s;
  z-index: 100;
  box-shadow: 0 4px 12px rgba(0,0,0,.3);
  margin-bottom: 4px;
}
.legend-item:hover .tooltip{
  opacity: 1;
  visibility: visible;
}

    /* Стили для детализации прогноза */
.legend-item.clickable {
  cursor: pointer;
  transition: transform 0.1s, background 0.1s;
}
.legend-item.clickable:hover {
  transform: translateY(-1px);
  background: rgba(109,211,251,.1);
}

.forecast-detail-modal .modal-content {
  max-width: 550px;
}

.forecast-info-grid {
  display: grid;
  grid-template-columns: 1fr;
  gap: 16px;
  margin: 20px 0;
}

.forecast-card {
  background: #0f1326;
  border: 1px solid #27305a;
  border-radius: 12px;
  padding: 16px;
}

.forecast-card.highlight {
  background: linear-gradient(135deg, rgba(109,211,251,.06), rgba(167,139,250,.06));
  border-color: #4338ca;
}

.forecast-card.warning {
  background: rgba(255,138,138,.08);
  border-color: #dc2626;
}

.forecast-card.success {
  background: rgba(134,239,172,.08);
  border-color: #4ade80;
}

.forecast-label {
  font-size: 12px;
  color: var(--muted);
  margin-bottom: 8px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}

.forecast-value {
  font-size: 20px;
  font-weight: 700;
  margin-bottom: 4px;
}

.forecast-value.danger {
  color: #ff4444;
}

.forecast-value.success {
  color: #4ade80;
}

.forecast-value.warning {
  color: #ffb86b;
}

.forecast-description {
  font-size: 13px;
  color: var(--muted);
  line-height: 1.5;
  margin-top: 8px;
}

.forecast-comparison {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
  margin-top: 16px;
}

.comparison-item {
  background: #0b0f1e;
  border: 1px solid #1f2937;
  border-radius: 8px;
  padding: 12px;
  text-align: center;
}

.comparison-label {
  font-size: 11px;
  color: var(--muted);
  margin-bottom: 4px;
}

.comparison-value {
  font-size: 16px;
  font-weight: 600;
}

.forecast-timeline {
  margin-top: 16px;
  padding: 12px;
  background: #0b0f1e;
  border: 1px solid #1f2937;
  border-radius: 8px;
}

.timeline-bar {
  height: 8px;
  background: #1f2937;
  border-radius: 4px;
  position: relative;
  margin: 12px 0;
}

.timeline-progress {
  height: 100%;
  border-radius: 4px;
  position: absolute;
  left: 0;
  top: 0;
}

.timeline-marker {
  position: absolute;
  top: -6px;
  width: 20px;
  height: 20px;
  background: var(--accent);
  border: 2px solid var(--bg);
  border-radius: 50%;
  transform: translateX(-50%);
}

.forecast-alert {
  display: flex;
  align-items: start;
  gap: 10px;
  padding: 12px;
  background: rgba(255,138,138,.08);
  border: 1px solid #dc2626;
  border-radius: 8px;
  margin-top: 16px;
}

.forecast-alert.info {
  background: rgba(109,211,251,.08);
  border-color: #4338ca;
}

.forecast-alert-icon {
  font-size: 18px;
  flex-shrink: 0;
}

.forecast-alert-text {
  font-size: 13px;
  line-height: 1.5;
}

    /* Улучшенный график */
#chartWrap {
  background: linear-gradient(135deg, #0d1122 0%, #141829 100%);
  border: 1px solid #27305a;
  border-radius: 16px;
  padding: 16px;
  position: relative;
  box-shadow: 0 10px 40px rgba(0,0,0,.3), inset 0 1px 0 rgba(255,255,255,.03);
}

#chart {
  width: 100%;
  height: 360px;
  display: block;
  cursor: crosshair;
}

.chart-tooltip {
  position: absolute;
  background: rgba(23, 27, 46, 0.98);
  border: 1px solid var(--accent);
  border-radius: 8px;
  padding: 10px;
  pointer-events: none;
  z-index: 100;
  font-size: 12px;
  box-shadow: 0 8px 24px rgba(0,0,0,.4);
  backdrop-filter: blur(10px);
  display: none;
  min-width: 180px;
}

.chart-tooltip.show {
  display: block;
}

.tooltip-header {
  font-weight: 600;
  color: var(--accent);
  margin-bottom: 6px;
  padding-bottom: 6px;
  border-bottom: 1px solid rgba(109,211,251,.2);
}

.tooltip-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 4px 0;
}

.tooltip-label {
  color: var(--muted);
  display: flex;
  align-items: center;
  gap: 6px;
}

.tooltip-value {
  font-weight: 600;
  color: var(--text);
}

.tooltip-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  display: inline-block;
}

.chart-controls {
  display: flex;
  gap: 8px;
  margin-bottom: 12px;
  flex-wrap: wrap;
}

.chart-toggle {
  padding: 6px 12px;
  background: rgba(109,211,251,.1);
  border: 1px solid #27305a;
  border-radius: 20px;
  color: var(--muted);
  font-size: 12px;
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  gap: 6px;
}

.chart-toggle:hover {
  background: rgba(109,211,251,.2);
  border-color: var(--accent);
  color: var(--accent);
  transform: translateY(-1px);
}

.chart-toggle.active {
  background: var(--accent);
  color: #0f1220;
  border-color: var(--accent);
}

.chart-toggle .toggle-dot {
  width: 8px;
  height: 8px;
  border-radius: 50%;
}

.legend {
  display: flex;
  gap: 10px;
  flex-wrap: wrap;
  margin: 12px 0 0;
  padding: 12px;
  background: rgba(0,0,0,.2);
  border-radius: 8px;
}

.legend-item {
  transition: all 0.2s;
}

.legend-item:hover {
  transform: scale(1.05);
}

.chart-gradient-defs {
  position: absolute;
  width: 0;
  height: 0;
  visibility: hidden;
}

@keyframes chartFadeIn {
  from {
    opacity: 0;
    transform: translateY(10px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

.chart-animated {
  animation: chartFadeIn 0.5s ease-out;
}
    
    

  </style>
</head>
<body>
  <div id="app">
    <h1>Финансовый Планер</h1>
    <div class="sub">Наведи порядок в тратах и уверенно двигайся к цели. Заполни поля, добавь обязательные платежи с датами оплаты и смотри, как меняется доступный лимит.</div>

    <div class="grid">
      <!-- ВВОД ДАННЫХ -->
      <section id="input-section">
        <h2>Ваш план</h2>

        <div class="field">
          <label for="initial">Начальный капитал, ₽</label>
          <input id="initial" type="number" inputmode="decimal" min="0" step="100" placeholder="например, 100000" />
        </div>

        <div class="field">
          <label for="target">Целевой баланс к концу периода, ₽</label>
          <input id="target" type="number" inputmode="decimal" min="0" step="100" placeholder="например, 50000" />
        </div>

        <div class="row">
          <div class="field">
            <label for="start">Начальная дата</label>
            <input id="start" type="date" />
          </div>
          <div class="field">
            <label for="end">Конечная дата</label>
            <input id="end" type="date" />
          </div>
        </div>

        <!-- Обязательные платежи -->
        <div class="mandatory-section">
          <div class="mandatory-header">
            <div class="mandatory-title">Обязательные платежи</div>
            <button class="btn accent small" onclick="openMandatoryModal()">+ Добавить</button>
          </div>
          <div id="mandatoryList" class="mandatory-list">
            <div class="note">Нет обязательных платежей</div>
          </div>
        </div>

        <div class="actions">
          <button id="calcBtn" class="btn">Рассчитать</button>
          <button id="resetBtn" class="btn ghost">Сбросить</button>
          <span class="pill" id="monthsInfo">Месяцев: —</span>
        </div>
        <div class="note">Обязательные платежи учитываются только если дата оплаты попадает в период планирования.</div>
      </section>

      <!-- РЕЗУЛЬТАТЫ И ГРАФИК -->
      <section id="results-section">
        <h2>Результаты</h2>

        <div class="kpi">
          <div class="tile">
            <div class="label">Доступно для трат за период</div>
            <div class="value" id="availableTotal">—</div>
            <div class="small">После вычета обязательных</div>
          </div>

          <div class="tile" id="limitTile">
            <div class="label">Лимит трат в месяц (базовый)</div>
            <div class="value" id="monthlyLimit">—</div>
            <div class="small">Без учёта фактических</div>
          </div>

          <div class="tile">
            <div class="label">Обязательные платежи за период</div>
            <div class="value" id="mandatoryTotal">—</div>
          </div>

          <div class="tile" id="feasibilityTile">
            <div class="label">Состояние плана</div>
            <div class="value" id="feasibility">—</div>
          </div>
        </div>

        <!-- Рекомендации -->
        <div id="recommendationsBlock" class="recommendations hidden">
          <div class="rec-title">💡 Рекомендуемые лимиты</div>
          <div class="rec-grid">
            <div class="rec-item">
              <div class="rec-label">В день</div>
              <div class="rec-value" id="dailyLimit">—</div>
            </div>
            <div class="rec-item">
              <div class="rec-label">В неделю</div>
              <div class="rec-value" id="weeklyLimit">—</div>
            </div>
            <div class="rec-item">
              <div class="rec-label">В 10 дней</div>
              <div class="rec-value" id="tenDaysLimit">—</div>
            </div>
          </div>
        </div>

        <div class="divider"></div>

        <div id="chartWrap" class="chart-animated">
  <div class="chart-controls">
    <button class="chart-toggle active" data-line="plan" onclick="toggleChartLine('plan')">
      <span class="toggle-dot" style="background: #7aa2ff"></span>
      План
    </button>
    <button class="chart-toggle active" data-line="actual" onclick="toggleChartLine('actual')">
      <span class="toggle-dot" style="background: #ffb86b"></span>
      Фактический
    </button>
    <button class="chart-toggle active" data-line="forecast" onclick="toggleChartLine('forecast')">
      <span class="toggle-dot" style="background: #4ade80"></span>
      Равномерный прогноз
    </button>
    <button class="chart-toggle active" data-line="trend" onclick="toggleChartLine('trend')">
      <span class="toggle-dot" style="background: #ff6b6b"></span>
      Прогноз по истории
    </button>
  </div>
  
  <canvas id="chart"></canvas>
  
  <div class="chart-tooltip" id="chartTooltip">
    <div class="tooltip-header" id="tooltipHeader">—</div>
    <div id="tooltipContent"></div>
  </div>
  
  <div class="legend">
    <span class="pill legend-item">
      <span class="dot plan"></span> План по балансу
    </span>
    <span class="pill legend-item">
      <span class="dot actual"></span> Фактический баланс
    </span>
    <span class="pill legend-item clickable" onclick="openForecastDetailModal('uniform')">
      <span class="dot forecast"></span> Прогноз равномерный
      <span class="info-icon">📊</span>
      <span class="tooltip">Клик для подробностей</span>
    </span>
    <span class="pill legend-item clickable" onclick="openForecastDetailModal('trend')">
      <span class="dot trend"></span> Прогноз по истории
      <span class="info-icon">📊</span>
      <span class="tooltip">Клик для подробностей</span>
    </span>
  </div>
</div>
      </section>
    </div>

    <!-- ФАКТИЧЕСКИЕ ТРАТЫ -->
    <section id="actual-spending-section">
      <h2>Фактические траты по месяцам</h2>
      <div class="note">Добавляй расходы через кнопку "+" для каждого месяца. Обязательные платежи отображаются автоматически.</div>
      
      <div id="monthsList" class="months"></div>

      <div class="divider"></div>

      <div class="kpi">
        <div class="tile">
          <div class="label">Учтено месяцев</div>
          <div class="value" id="countSaved">—</div>
        </div>
        <div class="tile">
          <div class="label">Сумма фактических трат</div>
          <div class="value" id="sumActual">—</div>
        </div>
        <div class="tile">
          <div class="label">Осталось на период</div>
          <div class="value" id="remainingTotal">—</div>
        </div>
        <div class="tile highlight" id="newLimitTile">
          <div class="label">Новый лимит в месяц</div>
          <div class="value" id="newMonthlyLimit">—</div>
          <div class="small">С учётом фактических трат</div>
        </div>
      </div>

      <div id="unfeasibleMsg" class="tile warn hidden" style="margin-top:10px;">
        <div class="label warn-text">Предупреждение</div>
        <div class="value" style="font-size:16px;font-weight:600;">
          План невыполним. Увеличьте период или уменьшите обязательные платежи.
        </div>
      </div>
    </section>
  </div>

  <!-- Модальное окно для добавления траты -->
  <div id="addExpenseModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="modal-title">Добавить расход</h3>
        <button class="modal-close" onclick="closeModal()">×</button>
      </div>
      <div class="field">
        <label>Месяц</label>
        <input type="text" id="modalMonth" readonly style="background:#0b0f1e;">
      </div>
      <div class="field">
        <label for="expenseAmount">Сумма расхода, ₽</label>
        <input type="number" id="expenseAmount" inputmode="decimal" min="0" step="100" placeholder="например, 5000">
      </div>
      <div class="field">
        <label for="expenseDesc">Описание (необязательно)</label>
        <input type="text" id="expenseDesc" placeholder="например, Продукты">
      </div>
      <div class="actions">
        <button class="btn accent" onclick="saveExpense()">Добавить</button>
        <button class="btn ghost" onclick="closeModal()">Отмена</button>
      </div>
    </div>
  </div>

  <!-- Модальное окно для обязательных платежей -->
  <div id="mandatoryModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="modal-title">Добавить обязательный платеж</h3>
        <button class="modal-close" onclick="closeMandatoryModal()">×</button>
      </div>
      <div class="field">
        <label for="mandatoryName">Название платежа</label>
        <input type="text" id="mandatoryName" placeholder="например, Аренда квартиры">
      </div>
      <div class="field">
        <label for="mandatoryAmount">Сумма платежа, ₽</label>
        <input type="number" id="mandatoryAmount" inputmode="decimal" min="0" step="100" placeholder="например, 30000">
      </div>
      <div class="field">
        <label for="mandatoryDay">День месяца для оплаты (1-31)</label>
        <input type="number" id="mandatoryDay" min="1" max="31" placeholder="например, 5">
        <small class="note">Платеж будет учитываться только в месяцах, где эта дата попадает в период планирования</small>
      </div>
      <div class="actions">
        <button class="btn accent" onclick="saveMandatory()">Добавить</button>
        <button class="btn ghost" onclick="closeMandatoryModal()">Отмена</button>
      </div>
    </div>
  </div>

    <!-- Модальное окно детального просмотра месяца -->
  <div id="monthDetailModal" class="modal">
    <div class="modal-content">
      <div class="modal-header">
        <h3 class="modal-title" id="monthDetailTitle">Детали месяца</h3>
        <button class="modal-close" onclick="closeMonthDetailModal()">×</button>
      </div>
      
      <div class="pie-chart-container">
        <canvas id="pieChart" width="280" height="280"></canvas>
      </div>
      
      <div class="chart-legend">
        <div class="legend-item">
          <div class="legend-color" style="background: #4ade80;"></div>
          <span>Доступно для трат</span>
          <span id="legendAvailable" style="margin-left:auto; font-weight:600;">—</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #ff8a8a;"></div>
          <span>Потрачено (в пределах плана)</span>
          <span id="legendSpent" style="margin-left:auto; font-weight:600;">—</span>
        </div>
        <div class="legend-item" id="overspentLegend" style="display:none;">
          <div class="legend-color" style="background: #ff4444;"></div>
          <span>Перерасход</span>
          <span id="legendOverspent" style="margin-left:auto; font-weight:600; color:#ff4444;">—</span>
        </div>
      </div>
      
      <div class="detail-stats">
        <div class="detail-stat">
          <div class="detail-stat-label">План на месяц</div>
          <div class="detail-stat-value" id="detailPlan">—</div>
        </div>
        <div class="detail-stat">
          <div class="detail-stat-label">Обязательные платежи</div>
          <div class="detail-stat-value" id="detailMandatory">—</div>
        </div>
        <div class="detail-stat">
          <div class="detail-stat-label">Фактически потрачено</div>
          <div class="detail-stat-value" id="detailActual">—</div>
        </div>
        <div class="detail-stat">
          <div class="detail-stat-label">Остаток/Перерасход</div>
          <div class="detail-stat-value" id="detailBalance">—</div>
        </div>
      </div>
      
      <div class="actions" style="margin-top: 20px;">
        <button class="btn ghost" onclick="closeMonthDetailModal()">Закрыть</button>
      </div>
    </div>
  </div>

  <!-- Модальное окно детализации прогноза -->
<div id="forecastDetailModal" class="modal forecast-detail-modal">
  <div class="modal-content">
    <div class="modal-header">
      <h3 class="modal-title" id="forecastDetailTitle">Детали прогноза</h3>
      <button class="modal-close" onclick="closeForecastDetailModal()">×</button>
    </div>
    
    <div id="forecastContent">
      <!-- Содержимое будет добавляться динамически -->
    </div>
    
    <div class="actions" style="margin-top: 20px;">
      <button class="btn ghost" onclick="closeForecastDetailModal()">Закрыть</button>
    </div>
  </div>
</div>


  <script>
    // ===========================
    // УТИЛИТЫ
    // ===========================
    const fmt = new Intl.NumberFormat('ru-RU', { style:'currency', currency:'RUB', maximumFractionDigits:0 });
    const fmt0 = (n)=> n===null || Number.isNaN(n) ? '—' : fmt.format(n);
    const fmtShort = (n)=> {
      if(!Number.isFinite(n)) return '—';
      if(n >= 1000000) return (n/1000000).toFixed(1) + 'M';
      if(n >= 1000) return (n/1000).toFixed(1) + 'K';
      return Math.round(n).toString();
    };

    function num(el){
      const v = parseFloat(el.value.replace(',', '.'));
      return Number.isFinite(v) ? v : 0;
    }

    function monthsDiffCeil(start, end){
      if(!start || !end) return 0;
      const s = new Date(start.getFullYear(), start.getMonth(), start.getDate());
      const e = new Date(end.getFullYear(), end.getMonth(), end.getDate());
      if(e <= s) return 0;
      let diff = (e.getFullYear() - s.getFullYear()) * 12 + (e.getMonth() - s.getMonth());
      if(e.getDate() > s.getDate()) diff += 1;
      return diff;
    }

    function monthLabels(start, months){
      const labels = [];
      for(let i=0;i<months;i++){
        const d = new Date(start.getFullYear(), start.getMonth()+i, 1);
        const label = d.toLocaleDateString('ru-RU', { month:'long', year:'numeric' });
        labels.push(capitalize(label));
      }
      return labels;
    }
    
    function capitalize(s){ return s ? s[0].toUpperCase()+s.slice(1) : s; }

    function isCurrentMonth(monthIndex){
      if(!state.start) return false;
      const now = new Date();
      const monthDate = new Date(state.start.getFullYear(), state.start.getMonth() + monthIndex, 1);
      return now.getFullYear() === monthDate.getFullYear() && now.getMonth() === monthDate.getMonth();
    }

    // ===========================
    // СОСТОЯНИЕ ПРИЛОЖЕНИЯ
    // ===========================
    const state = {
      initial: 0,
      target: 0,
      start: null,
      end: null,
      months: 0,
      mandatoryPayments: [], // Массив обязательных платежей [{name, amount, dayOfMonth}]
      monthlyTransactions: [], // Массив массивов транзакций по месяцам
      labels: [],
      currentModalMonth: -1,
      collapsedMonths: {} // Добавьте эту строку для хранения состояния сворачивания
    };

    // Локальное хранилище
    const STORAGE_KEY = 'finplanner_state_v3';
    function saveState(){
      try{
        const payload = {
          ...state,
          start: state.start ? state.start.toISOString() : null,
          end: state.end ? state.end.toISOString() : null,
          collapsedMonths: state.collapsedMonths // Добавьте эту строку
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      }catch(e){}
    }
    
    function loadState(){
      try{
        const raw = localStorage.getItem(STORAGE_KEY);
        if(!raw) return;
        const obj = JSON.parse(raw);
        state.initial = obj.initial ?? 0;
        state.target = obj.target ?? 0;
        state.start = obj.start ? new Date(obj.start) : null;
        state.end = obj.end ? new Date(obj.end) : null;
        state.months = obj.months ?? 0;
        state.mandatoryPayments = obj.mandatoryPayments ?? [];
        state.monthlyTransactions = obj.monthlyTransactions ?? [];
        state.labels = obj.labels ?? [];
        state.collapsedMonths = obj.collapsedMonths ?? {}; // Добавьте эту строку
      }catch(e){}
    }

    // ===========================
    // РАСЧЕТ ОБЯЗАТЕЛЬНЫХ ПЛАТЕЖЕЙ
    // ===========================
    function calculateMandatoryForMonth(monthIndex){
      if(!state.start || !state.end) return 0;
      
      const monthStart = new Date(state.start.getFullYear(), state.start.getMonth() + monthIndex, 1);
      const monthEnd = new Date(state.start.getFullYear(), state.start.getMonth() + monthIndex + 1, 0);
      
      let total = 0;
      
      for(const payment of state.mandatoryPayments){
        const paymentDate = new Date(monthStart.getFullYear(), monthStart.getMonth(), payment.dayOfMonth);
        
        // Проверяем, что дата платежа попадает в период планирования
        if(paymentDate >= state.start && paymentDate <= state.end){
          // И что дата существует в этом месяце
          if(paymentDate.getMonth() === monthStart.getMonth()){
            total += payment.amount;
          }
        }
      }
      
      return total;
    }

    function calculateTotalMandatory(){
      let total = 0;
      for(let i = 0; i < state.months; i++){
        total += calculateMandatoryForMonth(i);
      }
      return total;
    }

    function calculateTotalMandatory(){
      let total = 0;
      for(let i = 0; i < state.months; i++){
        total += calculateMandatoryForMonth(i);
      }
      return total;
    }

     // ===========================
    // РАСЧЕТ ДИНАМИЧЕСКИХ ЛИМИТОВ
    // ===========================
    function calculateDynamicLimitForMonth(monthIndex, baseMonthlyLimit, monthlyActuals){
      // Для первого месяца возвращаем базовый лимит если в нем еще нет трат
      if(monthIndex === 0 && monthlyActuals[0] === 0){
        return baseMonthlyLimit;
      }
      
      // Находим последний месяц с тратами
      let lastMonthWithExpenses = -1;
      for(let i = 0; i < monthlyActuals.length; i++){
        if(monthlyActuals[i] > 0){
          lastMonthWithExpenses = i;
        }
      }
      
      // Если текущий месяц уже имеет траты или это прошедший месяц - показываем базовый план
      if(monthIndex <= lastMonthWithExpenses){
        return baseMonthlyLimit;
      }
      
      // Для будущих месяцев пересчитываем план
      // Считаем сколько уже потрачено (включая обязательные)
      let totalSpentSoFar = 0;
      for(let i = 0; i <= lastMonthWithExpenses; i++){
        totalSpentSoFar += monthlyActuals[i] + calculateMandatoryForMonth(i);
      }
      
      // Считаем сколько осталось обязательных платежей в будущих месяцах
      let futureMandatory = 0;
      for(let i = lastMonthWithExpenses + 1; i < state.months; i++){
        futureMandatory += calculateMandatoryForMonth(i);
      }
      
      // Общая доступная сумма за весь период
      const totalAvailableForPeriod = (state.initial - state.target) - calculateTotalMandatory();
      
      // Сколько осталось после фактических трат (без учета обязательных, так как они уже вычтены из totalAvailableForPeriod)
      const actualSpentWithoutMandatory = monthlyActuals.reduce((sum, v) => sum + v, 0);
      const remainingAfterActual = totalAvailableForPeriod - actualSpentWithoutMandatory;
      
      // Количество оставшихся месяцев (после последнего месяца с тратами)
      const remainingMonths = state.months - lastMonthWithExpenses - 1;
      
      // Новый равномерный лимит для всех оставшихся месяцев
      if(remainingMonths > 0){
        return remainingAfterActual / remainingMonths;
      }
      
      return 0;
    }

    // ===========================
    // РАСЧЕТ СРЕДНЕЙ ТРАТЫ ЗА ДЕНЬ
    // ===========================
    function calculateDailyAverage(monthIndex, dynamicLimit) {
  if (!state.start || !state.end) return null;
  if (!isCurrentMonth(monthIndex)) return null;
  
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  
  // Границы месяца
  const monthStart = new Date(state.start.getFullYear(), state.start.getMonth() + monthIndex, 1);
  const monthEnd = new Date(state.start.getFullYear(), state.start.getMonth() + monthIndex + 1, 0);
  
  // Определяем начало отсчета
  let countStart;
  if (monthIndex === 0) {
    // Для первого месяца берем дату начала плана
    countStart = new Date(state.start.getFullYear(), state.start.getMonth(), state.start.getDate());
  } else {
    // Для остальных месяцев - первое число
    countStart = monthStart;
  }
  
  // Определяем конец отсчета (минимум из: сегодня, конец месяца, конец плана)
  let countEnd = today;
  if (monthEnd < countEnd) countEnd = monthEnd;
  if (state.end < countEnd) countEnd = state.end;
  
  // Проверяем, что интервал валидный
  if (countEnd < countStart) return null;
  
  // Считаем количество дней (включительно)
  const daysCount = Math.floor((countEnd - countStart) / (1000 * 60 * 60 * 24)) + 1;
  
  // Получаем транзакции текущего месяца
  const transactions = state.monthlyTransactions[monthIndex] || [];
  
  // Считаем сумму трат за период
  let totalSpent = 0;
  transactions.forEach(t => {
    const transDate = new Date(t.date);
    const transDateOnly = new Date(transDate.getFullYear(), transDate.getMonth(), transDate.getDate());
    if (transDateOnly >= countStart && transDateOnly <= countEnd) {
      totalSpent += t.amount || 0;
    }
  });
  
  const dailyAvg = totalSpent / daysCount;
  
  // Рассчитываем рекомендуемый лимит
  const recommendedDailyLimit = dynamicLimit / 30; // Примерно 30 дней в месяце
  const recommendedTotalForDays = recommendedDailyLimit * daysCount;
  
  // Определяем статус (хорошо/нормально/плохо)
  const percentage = (totalSpent / recommendedTotalForDays) * 100;
  let status = 'normal';
  if (percentage < 90) status = 'good';
  else if (percentage > 110) status = 'bad';
  
  return {
    average: dailyAvg,
    days: daysCount,
    total: totalSpent,
    recommendedDaily: recommendedDailyLimit,
    recommendedTotal: recommendedTotalForDays,
    percentage: percentage,
    status: status
  };
}


    // ===========================
    // УПРАВЛЕНИЕ СВОРАЧИВАНИЕМ МЕСЯЦЕВ
    // ===========================
    function toggleMonth(monthIndex) {
      const monthId = `month_${monthIndex}`;
      state.collapsedMonths[monthId] = !state.collapsedMonths[monthId];
      saveState();
      
      const monthDiv = document.querySelector(`[data-month-index="${monthIndex}"]`);
      if (monthDiv) {
        if (state.collapsedMonths[monthId]) {
          monthDiv.classList.add('collapsed');
        } else {
          monthDiv.classList.remove('collapsed');
        }
        
        const toggleBtn = monthDiv.querySelector('.month-toggle-btn');
        if (toggleBtn) {
          if (state.collapsedMonths[monthId]) {
            toggleBtn.classList.add('collapsed');
          } else {
            toggleBtn.classList.remove('collapsed');
          }
        }
      }
    }

    // ===========================
    // DOM ЭЛЕМЕНТЫ
    // ===========================
    const $initial = document.getElementById('initial');
    const $target = document.getElementById('target');
    const $start = document.getElementById('start');
    const $end = document.getElementById('end');
    const $calcBtn = document.getElementById('calcBtn');
    const $resetBtn = document.getElementById('resetBtn');
    const $monthsInfo = document.getElementById('monthsInfo');
    const $availableTotal = document.getElementById('availableTotal');
    const $monthlyLimit = document.getElementById('monthlyLimit');
    const $mandatoryTotal = document.getElementById('mandatoryTotal');
    const $feasibility = document.getElementById('feasibility');
    const $limitTile = document.getElementById('limitTile');
    const $feasibilityTile = document.getElementById('feasibilityTile');
    const $monthsList = document.getElementById('monthsList');
    const $countSaved = document.getElementById('countSaved');
    const $sumActual = document.getElementById('sumActual');
    const $remainingTotal = document.getElementById('remainingTotal');
    const $newMonthlyLimit = document.getElementById('newMonthlyLimit');
    const $newLimitTile = document.getElementById('newLimitTile');
    const $unfeasibleMsg = document.getElementById('unfeasibleMsg');
    const $recommendationsBlock = document.getElementById('recommendationsBlock');
    const $dailyLimit = document.getElementById('dailyLimit');
    const $weeklyLimit = document.getElementById('weeklyLimit');
    const $tenDaysLimit = document.getElementById('tenDaysLimit');
    const $chart = document.getElementById('chart');
    const ctx = $chart.getContext('2d');
    const $mandatoryList = document.getElementById('mandatoryList');

    // ===========================
    // ОСНОВНАЯ ЛОГИКА
    // ===========================
    function recalcAll(){
  state.initial = Math.max(0, num($initial));
  state.target = Math.max(0, num($target));
  state.start = $start.value ? new Date($start.value) : null;
  state.end = $end.value ? new Date($end.value) : null;
  state.months = monthsDiffCeil(state.start, state.end);
  $monthsInfo.textContent = `Месяцев: ${state.months || '—'}`;

  if(state.months <= 0 || !state.start || !state.end){
    state.labels = [];
    state.monthlyTransactions = [];
    renderResults({availableTotal:null, monthlyLimit:null, mandatoryTotal:null, feasible:null, newMonthlyLimit:null, remTotal:null, sumActual:null, countSaved:null});
    $monthsList.innerHTML = '';
    drawChart([], [], [], [], []);
    $recommendationsBlock.classList.add('hidden');
    saveState();
    return;
  }

  state.labels = monthLabels(state.start, state.months);
  
  // Инициализация транзакций по месяцам
  if(state.monthlyTransactions.length !== state.months){
    const next = new Array(state.months).fill(null).map((_, i) => 
      state.monthlyTransactions[i] || []
    );
    state.monthlyTransactions = next;
  }

  // Расчёты с учетом обязательных платежей
  const mandatoryTotal = calculateTotalMandatory();
  const availableTotal = (state.initial - state.target) - mandatoryTotal;
  const monthlyLimit = availableTotal / state.months;
  
  // Подсчёт фактических трат
  const monthlyActuals = state.monthlyTransactions.map(transactions => 
    transactions.reduce((sum, t) => sum + (t.amount || 0), 0)
  );
  const countSaved = monthlyActuals.filter(v => v > 0).length;
  const sumActual = monthlyActuals.reduce((sum, v) => sum + v, 0);
  
  const remTotal = availableTotal - sumActual;
  const remainingMonths = Math.max(0, state.months - countSaved);
  const newMonthlyLimit = remainingMonths > 0 ? (remTotal / remainingMonths) : 0;
  const feasible = monthlyLimit >= 0 && remTotal >= 0;

  renderResults({
    availableTotal,
    monthlyLimit,
    mandatoryTotal,
    feasible,
    newMonthlyLimit,
    remTotal,
    sumActual,
    countSaved
  });

  renderMandatoryPayments();
  renderMonthsList(monthlyLimit, newMonthlyLimit);
  renderRecommendations(newMonthlyLimit);

  // График
  const plannedBalances = makePlannedBalances(state.initial, state.target, state.months);
  const { actualBalances, forecastBalances } = makeActualAndForecastBalances(
    plannedBalances, state.initial, monthlyActuals, newMonthlyLimit
  );
  
  // Создаем массив обязательных платежей по месяцам для прогноза
  const mandatoryByMonth = [];
  for(let i = 0; i < state.months; i++){
    mandatoryByMonth.push(calculateMandatoryForMonth(i));
  }
  
  // Добавляем прогноз на основе истории
  const trendForecastBalances = makeTrendForecastBalances(state.initial, monthlyActuals, mandatoryByMonth);
  
  drawChart(state.labels, plannedBalances, actualBalances, forecastBalances, trendForecastBalances);

  saveState();
}

    function renderMandatoryPayments(){
      if(state.mandatoryPayments.length === 0){
        $mandatoryList.innerHTML = '<div class="note">Нет обязательных платежей</div>';
        return;
      }

      $mandatoryList.innerHTML = '';
      state.mandatoryPayments.forEach((payment, idx) => {
        const div = document.createElement('div');
        div.className = 'mandatory-item';
        div.innerHTML = `
          <div class="mandatory-info">
            <div class="mandatory-name">${payment.name}</div>
            <div class="mandatory-details">Оплата: ${payment.dayOfMonth} числа каждого месяца</div>
          </div>
          <div class="mandatory-amount">${fmt0(payment.amount)}</div>
          <button class="btn danger small" onclick="deleteMandatory(${idx})">Удалить</button>
        `;
        $mandatoryList.appendChild(div);
      });
    }

    function renderRecommendations(monthlyLimit){
      if(!Number.isFinite(monthlyLimit) || monthlyLimit <= 0){
        $recommendationsBlock.classList.add('hidden');
        return;
      }
      $recommendationsBlock.classList.remove('hidden');
      const daily = monthlyLimit / 30;
      const weekly = monthlyLimit / 4.3;
      const tenDays = monthlyLimit / 3;
      
      $dailyLimit.textContent = fmtShort(daily) + ' ₽';
      $weeklyLimit.textContent = fmtShort(weekly) + ' ₽';
      $tenDaysLimit.textContent = fmtShort(tenDays) + ' ₽';
    }

    function makePlannedBalances(initial, target, months){
      const arr = [];
      for(let i=0;i<=months;i++){
        const t = i / months;
        const y = initial + (target - initial) * t;
        arr.push(y);
      }
      return arr;
    }

        function makeActualAndForecastBalances(planned, initial, monthlyActuals, newMonthlyLimit){
      const actual = [initial];
      let currentBalance = initial;
      let savedCount = 0;
      
      // Проходим по всем месяцам с фактическими тратами
      for(let i=0;i<monthlyActuals.length;i++){
        const v = monthlyActuals[i];
        const mandatoryForMonth = calculateMandatoryForMonth(i);
        
        if(v > 0){
          currentBalance = currentBalance - mandatoryForMonth - v;
          actual.push(currentBalance);
          savedCount++;
        }
        else {
          break;
        }
      }
      
      // Строим прогноз на оставшиеся месяцы
      const forecast = [];
      if(savedCount < state.months){
        forecast.push(currentBalance);
        
        // Считаем сколько осталось на все оставшиеся месяцы
        const totalAvailableForPeriod = (state.initial - state.target) - calculateTotalMandatory();
        const actualSpentWithoutMandatory = monthlyActuals.reduce((sum, v) => sum + v, 0);
        const remainingAfterActual = totalAvailableForPeriod - actualSpentWithoutMandatory;
        const remainingMonths = state.months - savedCount;
        const equalMonthlyLimit = remainingMonths > 0 ? remainingAfterActual / remainingMonths : 0;
        
        for(let i = savedCount; i < state.months; i++){
          const mandatoryForMonth = calculateMandatoryForMonth(i);
          const monthlyTotalSpend = mandatoryForMonth + Math.max(0, equalMonthlyLimit);
          currentBalance = currentBalance - monthlyTotalSpend;
          forecast.push(currentBalance);
        }
      }
      
      return { actualBalances: actual, forecastBalances: forecast };
    }

    function makeTrendForecastBalances(initial, monthlyActuals, mandatoryByMonth) {
  const forecast = [];
  let currentBalance = initial;
  
  // Определяем текущую дату и текущий месяц в плане
  const now = new Date();
  const currentMonthIndex = state.start ? 
    (now.getFullYear() - state.start.getFullYear()) * 12 + 
    (now.getMonth() - state.start.getMonth()) : -1;
  
  // Находим последний месяц с тратами
  let lastMonthWithExpenses = -1;
  let completedMonths = []; // Массив полностью завершенных месяцев
  let currentMonthData = null; // Данные по текущему незавершенному месяцу
  
  for(let i = 0; i < monthlyActuals.length; i++){
    if(monthlyActuals[i] > 0){
      lastMonthWithExpenses = i;
      currentBalance = currentBalance - monthlyActuals[i] - (mandatoryByMonth[i] || 0);
      
      // Определяем, завершен ли месяц
      if(i < currentMonthIndex || (i === currentMonthIndex && now > state.end)) {
        // Месяц полностью прошел
        completedMonths.push({
          index: i,
          spending: monthlyActuals[i],
          days: 30 // Примерное количество дней в месяце
        });
      } else if(i === currentMonthIndex) {
        // Это текущий месяц, он не завершен
        const monthStart = new Date(state.start.getFullYear(), state.start.getMonth() + i, 1);
        const monthEnd = new Date(state.start.getFullYear(), state.start.getMonth() + i + 1, 0);
        
        // Определяем сколько дней прошло в этом месяце
        let startDate = monthStart;
        if(i === 0 && state.start > monthStart) {
          startDate = state.start; // Для первого месяца учитываем дату начала плана
        }
        
        const endDate = now < monthEnd ? now : monthEnd;
        const daysElapsed = Math.max(1, Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1);
        const totalDaysInMonth = Math.floor((monthEnd - startDate) / (1000 * 60 * 60 * 24)) + 1;
        
        currentMonthData = {
          index: i,
          spending: monthlyActuals[i],
          daysElapsed: daysElapsed,
          totalDays: totalDaysInMonth,
          dailyRate: monthlyActuals[i] / daysElapsed,
          projectedMonthTotal: (monthlyActuals[i] / daysElapsed) * totalDaysInMonth
        };
      }
    }
  }
  
  // Если нет истории трат, возвращаем пустой массив
  if(lastMonthWithExpenses < 0) return [];
  
  // Начинаем прогноз с текущего баланса
  forecast.push(currentBalance);
  
  // Рассчитываем среднедневную трату на основе ДНЕЙ, а не месяцев
  let totalDaysWithData = 0;
  let totalSpending = 0;
  
  // Учитываем завершенные месяцы
  completedMonths.forEach(month => {
    totalDaysWithData += month.days;
    totalSpending += month.spending;
  });
  
  // Учитываем текущий незавершенный месяц
  if(currentMonthData) {
    totalDaysWithData += currentMonthData.daysElapsed;
    totalSpending += currentMonthData.spending;
  }
  
  // Средняя трата в день на основе фактических данных
  const avgDailySpending = totalDaysWithData > 0 ? totalSpending / totalDaysWithData : 0;
  
  // Если есть данные текущего месяца, используем их для более точного прогноза
  let projectedMonthlySpending = avgDailySpending * 30; // Базовый прогноз
  
  if(currentMonthData && currentMonthData.daysElapsed >= 3) {
    // Если в текущем месяце прошло хотя бы 3 дня, придаем больший вес его данным
    const currentMonthWeight = Math.min(0.7, currentMonthData.daysElapsed / 30);
    const historicalWeight = 1 - currentMonthWeight;
    
    projectedMonthlySpending = 
      (currentMonthData.dailyRate * 30 * currentMonthWeight) + 
      (avgDailySpending * 30 * historicalWeight);
  }
  
  // Определяем тренд (если есть достаточно данных)
  let trendFactor = 1;
  if(completedMonths.length >= 2) {
    const firstHalfAvg = completedMonths.slice(0, Math.floor(completedMonths.length/2))
      .reduce((sum, m) => sum + m.spending/m.days, 0) / Math.floor(completedMonths.length/2);
    const secondHalfAvg = completedMonths.slice(Math.floor(completedMonths.length/2))
      .reduce((sum, m) => sum + m.spending/m.days, 0) / (completedMonths.length - Math.floor(completedMonths.length/2));
    
    trendFactor = secondHalfAvg / firstHalfAvg;
  } else if(currentMonthData && currentMonthData.daysElapsed >= 7) {
    // Если есть только текущий месяц, но прошла хотя бы неделя
    // Сравниваем с рекомендуемым лимитом
    const recommendedDaily = (initial - state.target - calculateTotalMandatory()) / 
                            (state.months * 30);
    if(recommendedDaily > 0) {
      trendFactor = currentMonthData.dailyRate / recommendedDaily;
    }
  }
  
  // Строим прогноз для оставшихся месяцев
  for(let i = lastMonthWithExpenses + 1; i < state.months; i++){
    // Применяем тренд с затуханием
    const monthsAhead = i - lastMonthWithExpenses;
    const trendDamping = Math.pow(0.95, monthsAhead); // Тренд затухает на 5% каждый месяц
    const adjustedTrend = 1 + (trendFactor - 1) * trendDamping;
    
    const predictedSpending = projectedMonthlySpending * adjustedTrend;
    const mandatoryForMonth = mandatoryByMonth[i] || 0;
    
    currentBalance = currentBalance - predictedSpending - mandatoryForMonth;
    forecast.push(currentBalance);
  }
  
  return forecast;
}

    // ===========================
// ДЕТАЛИЗАЦИЯ ПРОГНОЗОВ
// ===========================
function calculateForecastDetails() {
  if (!state.start || !state.end || state.months <= 0) return null;
  
  const now = new Date();
  const currentMonthIndex = (now.getFullYear() - state.start.getFullYear()) * 12 + 
    (now.getMonth() - state.start.getMonth());
  
  // Получаем фактические траты
  const monthlyActuals = state.monthlyTransactions.map(transactions => 
    transactions.reduce((sum, t) => sum + (t.amount || 0), 0)
  );
  
  // Анализируем данные с учетом дней
  let totalDaysWithData = 0;
  let totalSpending = 0;
  let lastMonthWithExpenses = -1;
  let totalSpentSoFar = 0;
  
  for(let i = 0; i < monthlyActuals.length; i++){
    if(monthlyActuals[i] > 0){
      lastMonthWithExpenses = i;
      totalSpentSoFar += monthlyActuals[i] + calculateMandatoryForMonth(i);
      
      // Рассчитываем количество дней для этого месяца
      const monthStart = new Date(state.start.getFullYear(), state.start.getMonth() + i, 1);
      const monthEnd = new Date(state.start.getFullYear(), state.start.getMonth() + i + 1, 0);
      
      let startDate = monthStart;
      if(i === 0 && state.start > monthStart) {
        startDate = state.start;
      }
      
      let endDate = monthEnd;
      if(i === currentMonthIndex) {
        // Для текущего месяца считаем только прошедшие дни
        endDate = now < monthEnd ? now : monthEnd;
      }
      
      const daysInPeriod = Math.max(1, Math.floor((endDate - startDate) / (1000 * 60 * 60 * 24)) + 1);
      
      totalDaysWithData += daysInPeriod;
      totalSpending += monthlyActuals[i];
    }
  }
  
  // Если нет трат, возвращаем базовые значения
  if(lastMonthWithExpenses < 0){
    const mandatoryTotal = calculateTotalMandatory();
    const availableTotal = (state.initial - state.target) - mandatoryTotal;
    const monthlyLimit = availableTotal / state.months;
    
    return {
      uniform: {
        finalBalance: state.target,
        willComplete: monthlyLimit >= 0,
        monthlySpending: monthlyLimit,
        totalSpending: availableTotal,
        completionDate: state.end,
        runOutDate: null,
        remainingMonths: state.months,
        daysAnalyzed: 0
      },
      trend: null
    };
  }
  
  // Расчет для равномерного прогноза
  const mandatoryTotal = calculateTotalMandatory();
  const availableTotal = (state.initial - state.target) - mandatoryTotal;
  const sumActual = monthlyActuals.reduce((sum, v) => sum + v, 0);
  const remTotal = availableTotal - sumActual;
  const remainingMonths = state.months - lastMonthWithExpenses - 1;
  const newMonthlyLimit = remainingMonths > 0 ? (remTotal / remainingMonths) : 0;
  
  // Считаем оставшиеся обязательные платежи
  let futureMandatory = 0;
  for(let i = lastMonthWithExpenses + 1; i < state.months; i++){
    futureMandatory += calculateMandatoryForMonth(i);
  }
  
  const uniformFinalBalance = state.initial - totalSpentSoFar - 
    (newMonthlyLimit * remainingMonths) - futureMandatory;
  
  // Расчет для прогноза по истории на основе ДНЕЙ
  const avgDailySpending = totalDaysWithData > 0 ? totalSpending / totalDaysWithData : 0;
  const projectedMonthlySpending = avgDailySpending * 30;
  
  // Определяем тренд
  let trendGrowth = 0;
  if(totalDaysWithData >= 7) {
    // Сравниваем с рекомендуемым дневным лимитом
    const recommendedDaily = availableTotal / (state.months * 30);
    if(recommendedDaily > 0) {
      trendGrowth = (avgDailySpending - recommendedDaily) / recommendedDaily;
    }
  }
  
  // Прогнозируем баланс по истории
  let trendBalance = state.initial - totalSpentSoFar;
  let runOutMonth = -1;
  
  for(let i = lastMonthWithExpenses + 1; i < state.months; i++){
    const monthPredictedSpending = projectedMonthlySpending * (1 + trendGrowth * Math.pow(0.95, i - lastMonthWithExpenses));
    const mandatoryForMonth = calculateMandatoryForMonth(i);
    
    trendBalance -= (monthPredictedSpending + mandatoryForMonth);
    
    if(trendBalance < state.target && runOutMonth === -1){
      runOutMonth = i;
    }
  }
  
  // Рассчитываем дату исчерпания средств
  let runOutDate = null;
  if(runOutMonth >= 0){
    const daysPerMonth = 30;
    const remainingInCurrentMonth = trendBalance + projectedMonthlySpending + calculateMandatoryForMonth(runOutMonth - 1);
    const dailyRate = (projectedMonthlySpending + calculateMandatoryForMonth(runOutMonth)) / daysPerMonth;
    const daysUntilRunOut = dailyRate > 0 ? remainingInCurrentMonth / dailyRate : 30;
    
    runOutDate = new Date(state.start.getFullYear(), 
                          state.start.getMonth() + runOutMonth - 1, 
                          Math.max(1, Math.min(30, Math.floor(daysUntilRunOut))));
  }
  
  return {
    uniform: {
      finalBalance: uniformFinalBalance,
      willComplete: uniformFinalBalance >= state.target,
      monthlySpending: newMonthlyLimit,
      totalSpending: remTotal,
      completionDate: state.end,
      runOutDate: uniformFinalBalance < state.target ? runOutDate : null,
      remainingMonths: remainingMonths,
      daysAnalyzed: totalDaysWithData
    },
    trend: {
      finalBalance: trendBalance,
      willComplete: trendBalance >= state.target,
      avgDailySpending: avgDailySpending,
      avgSpending: projectedMonthlySpending,
      projectedSpending: projectedMonthlySpending,
      trendGrowth: trendGrowth,
      totalSpending: (projectedMonthlySpending * remainingMonths) + futureMandatory,
      completionDate: trendBalance >= state.target ? state.end : null,
      runOutDate: runOutDate,
      daysWithData: totalDaysWithData,
      percentOfRecommended: availableTotal > 0 ? (avgDailySpending / (availableTotal / (state.months * 30))) * 100 : 0
    }
  };
}

function openForecastDetailModal(type) {
  const details = calculateForecastDetails();
  if (!details) return;
  
  const modal = document.getElementById('forecastDetailModal');
  const content = document.getElementById('forecastContent');
  const title = document.getElementById('forecastDetailTitle');
  
  if (type === 'uniform') {
    title.textContent = 'Прогноз: Равномерные траты';
    content.innerHTML = renderUniformForecast(details.uniform);
  } else if (type === 'trend') {
    title.textContent = 'Прогноз: На основе истории';
    if (details.trend) {
      content.innerHTML = renderTrendForecast(details.trend);
    } else {
      content.innerHTML = `
        <div class="forecast-alert info">
          <div class="forecast-alert-icon">ℹ️</div>
          <div class="forecast-alert-text">
            Недостаточно данных для прогноза по истории. Добавьте траты хотя бы за один месяц.
          </div>
        </div>
      `;
    }
  }
  
  modal.classList.add('show');
}

function renderUniformForecast(data) {
  const statusClass = data.willComplete ? 'success' : 'warning';
  const statusText = data.willComplete ? 'План выполним' : 'План под угрозой';
  const statusIcon = data.willComplete ? '✓' : '⚠️';
  
  let html = `
    <div class="forecast-info-grid">
      <div class="forecast-card ${statusClass}">
        <div class="forecast-label">Статус прогноза</div>
        <div class="forecast-value">${statusIcon} ${statusText}</div>
        <div class="forecast-description">
          ${data.willComplete 
            ? 'При равномерных тратах вы достигнете целевого баланса' 
            : 'Текущий темп трат не позволит достичь цели'}
        </div>
      </div>
      
      <div class="forecast-card">
        <div class="forecast-label">Прогнозируемый баланс на ${state.end.toLocaleDateString('ru-RU')}</div>
        <div class="forecast-value ${data.finalBalance < state.target ? 'danger' : 'success'}">
          ${fmt0(data.finalBalance)}
        </div>
        <div class="forecast-description">
          Целевой баланс: ${fmt0(state.target)}
          ${data.finalBalance >= state.target 
            ? ` (запас ${fmt0(data.finalBalance - state.target)})` 
            : ` (недостаток ${fmt0(state.target - data.finalBalance)})`}
        </div>
      </div>
      
      <div class="forecast-card highlight">
        <div class="forecast-label">Рекомендуемые траты</div>
        <div class="forecast-comparison">
          <div class="comparison-item">
            <div class="comparison-label">В месяц</div>
            <div class="comparison-value">${fmt0(data.monthlySpending)}</div>
          </div>
          <div class="comparison-item">
            <div class="comparison-label">В день</div>
            <div class="comparison-value">${fmt0(data.monthlySpending / 30)}</div>
          </div>
        </div>
        <div class="forecast-description">
          Осталось ${data.remainingMonths} ${data.remainingMonths === 1 ? 'месяц' : data.remainingMonths < 5 ? 'месяца' : 'месяцев'} 
          из запланированных
        </div>
      </div>
    </div>
  `;
  
  if (!data.willComplete && data.runOutDate) {
    html += `
      <div class="forecast-alert">
        <div class="forecast-alert-icon">⚠️</div>
        <div class="forecast-alert-text">
          <strong>Внимание!</strong> При текущем уровне трат средства могут закончиться примерно 
          <strong>${data.runOutDate.toLocaleDateString('ru-RU')}</strong>, 
          что не позволит достичь целевого баланса к концу периода.
        </div>
      </div>
    `;
  }
  
  return html;
}

function renderTrendForecast(data) {
  const statusClass = data.willComplete ? 'success' : 'warning';
  const statusText = data.willComplete ? 'Цель достижима' : 'Цель под угрозой';
  const statusIcon = data.willComplete ? '✓' : '⚠️';
  const trendIcon = data.trendGrowth > 0.05 ? '📈' : data.trendGrowth < -0.05 ? '📉' : '➡️';
  const trendText = data.trendGrowth > 0.05 ? 'выше плана' : data.trendGrowth < -0.05 ? 'ниже плана' : 'по плану';
  
  // Определяем период анализа
  const daysText = data.daysWithData === 1 ? 'дня' : 
                   data.daysWithData < 5 ? 'дней' : 'дней';
  const periodText = data.daysWithData < 30 ? 
    `${data.daysWithData} ${daysText}` : 
    `${Math.floor(data.daysWithData / 30)} мес. ${data.daysWithData % 30} дн.`;
  
  let html = `
    <div class="forecast-info-grid">
      <div class="forecast-card ${statusClass}">
        <div class="forecast-label">Прогноз на основе ${periodText} фактических данных</div>
        <div class="forecast-value">${statusIcon} ${statusText}</div>
        <div class="forecast-description">
          ${data.willComplete 
            ? `При текущем темпе трат (${Math.round(data.percentOfRecommended)}% от рекомендуемого) вы достигнете цели` 
            : `Вы тратите ${Math.round(data.percentOfRecommended)}% от рекомендуемого лимита, что не позволит достичь цели`}
        </div>
      </div>
      
      <div class="forecast-card">
        <div class="forecast-label">Анализ ваших трат</div>
        <div class="forecast-value">${trendIcon} Траты ${trendText}</div>
        <div class="forecast-comparison">
          <div class="comparison-item">
            <div class="comparison-label">Средняя в день</div>
            <div class="comparison-value">${fmt0(data.avgDailySpending)}</div>
          </div>
          <div class="comparison-item">
            <div class="comparison-label">Прогноз на месяц</div>
            <div class="comparison-value">${fmt0(data.projectedSpending)}</div>
          </div>
        </div>
        ${data.percentOfRecommended !== 100 ? `
          <div class="forecast-description">
            Вы тратите ${data.percentOfRecommended > 100 ? 'на' : 'на'} 
            ${Math.abs(Math.round(data.percentOfRecommended - 100))}% 
            ${data.percentOfRecommended > 100 ? 'больше' : 'меньше'} рекомендуемого
          </div>
        ` : ''}
      </div>
      
      <div class="forecast-card ${data.finalBalance < state.target ? 'warning' : 'highlight'}">
        <div class="forecast-label">Прогнозируемый итог</div>
        <div class="forecast-value ${data.finalBalance < state.target ? 'danger' : 'success'}">
          ${fmt0(data.finalBalance)}
        </div>
        <div class="forecast-description">
          ${data.finalBalance >= state.target 
            ? `Вы достигнете цели с запасом ${fmt0(data.finalBalance - state.target)}` 
            : `До цели не хватит ${fmt0(state.target - data.finalBalance)}`}
        </div>
      </div>
    </div>
  `;
  
  if (!data.willComplete && data.runOutDate) {
    html += `
      <div class="forecast-alert">
        <div class="forecast-alert-icon">🔴</div>
        <div class="forecast-alert-text">
          <strong>Критическое предупреждение!</strong><br>
          При сохранении текущего темпа трат (${fmt0(data.avgDailySpending)}/день), 
          вы достигнете минимального баланса (${fmt0(state.target)}) уже 
          <strong>${data.runOutDate.toLocaleDateString('ru-RU')}</strong>.<br>
          Снизьте траты на ${Math.round(data.percentOfRecommended - 100)}% чтобы уложиться в план.
        </div>
      </div>
    `;
  } else if (data.willComplete) {
    const daysLeft = Math.floor((state.end - new Date()) / (1000 * 60 * 60 * 24));
    html += `
      <div class="forecast-alert info">
        <div class="forecast-alert-icon">💡</div>
        <div class="forecast-alert-text">
          <strong>Хорошие новости!</strong><br>
          Ваш текущий темп трат (${fmt0(data.avgDailySpending)}/день) позволит успешно достичь цели.<br>
          До конца периода осталось ${daysLeft} ${daysLeft === 1 ? 'день' : daysLeft < 5 ? 'дня' : 'дней'}.
          ${data.percentOfRecommended < 80 ? '<br>У вас даже есть запас для дополнительных трат!' : ''}
        </div>
      </div>
    `;
  }
  
  return html;
}

function closeForecastDetailModal() {
  document.getElementById('forecastDetailModal').classList.remove('show');
}


    function renderResults(data){
      const {
        availableTotal, monthlyLimit, mandatoryTotal,
        feasible, newMonthlyLimit, remTotal, sumActual, countSaved
      } = data;

      $availableTotal.textContent = fmt0(availableTotal);
      $monthlyLimit.textContent = Number.isFinite(monthlyLimit) ? fmt0(monthlyLimit) : '—';
      $mandatoryTotal.textContent = fmt0(mandatoryTotal);
      $feasibility.textContent = feasible===null ? '—' : (feasible ? 'Выполним ✓' : 'Невыполним ✗');
      $feasibilityTile.classList.toggle('warn', feasible===false);
      $feasibilityTile.classList.toggle('ok', feasible===true);
      $limitTile.classList.toggle('warn', Number.isFinite(monthlyLimit) && monthlyLimit < 0);
      $limitTile.classList.toggle('ok', Number.isFinite(monthlyLimit) && monthlyLimit >= 0);

      $countSaved.textContent = countSaved ?? '—';
      $sumActual.textContent = fmt0(sumActual);
      $remainingTotal.textContent = fmt0(remTotal);
      $newMonthlyLimit.textContent = Number.isFinite(newMonthlyLimit) ? fmt0(newMonthlyLimit) : '—';
      $newLimitTile.classList.toggle('warn', Number.isFinite(newMonthlyLimit) && newMonthlyLimit < 0);
      $newLimitTile.classList.toggle('ok', Number.isFinite(newMonthlyLimit) && newMonthlyLimit >= 0);

      const showUnfeasible = Number.isFinite(monthlyLimit) && monthlyLimit < 0;
      $unfeasibleMsg.classList.toggle('hidden', !showUnfeasible);
    }

        function renderMonthsList(baseMonthlyLimit, currentLimit){
  $monthsList.innerHTML = '';
  if(state.months <= 0) return;
  
  // Получаем фактические траты
  const monthlyActuals = state.monthlyTransactions.map(transactions => 
    transactions.reduce((sum, t) => sum + (t.amount || 0), 0)
  );

  state.labels.forEach((label, idx) => {
    const transactions = state.monthlyTransactions[idx] || [];
    const monthTotal = transactions.reduce((sum, t) => sum + (t.amount || 0), 0);
    const mandatoryForMonth = calculateMandatoryForMonth(idx);
    const hasTransactions = transactions.length > 0;
    const isCurrent = isCurrentMonth(idx);
    
    // Вычисляем динамический лимит для этого месяца
    const dynamicLimit = calculateDynamicLimitForMonth(idx, baseMonthlyLimit, monthlyActuals);
    
    // Рассчитываем среднюю трату за день для текущего месяца с новыми данными
    const dailyAverage = isCurrent ? calculateDailyAverage(idx, dynamicLimit) : null;
    
    const isOverspent = monthTotal > dynamicLimit;
    const isNegativeLimit = dynamicLimit < 0;

    const monthDiv = document.createElement('div');
    monthDiv.className = 'month' + (isCurrent ? ' current' : '');
    monthDiv.setAttribute('data-month-index', idx);
    
    // Определяем, должен ли месяц быть свернут
    const monthId = `month_${idx}`;
    const isCollapsed = !isCurrent && (state.collapsedMonths[monthId] !== false);
    if (isCollapsed) {
      monthDiv.classList.add('collapsed');
      state.collapsedMonths[monthId] = true;
    }
    
    if(isOverspent) monthDiv.style.borderColor = '#dc2626';
    if(isNegativeLimit) monthDiv.style.background = 'rgba(220, 38, 38, 0.1)';

    // Header с кнопкой сворачивания
    const header = document.createElement('div');
    header.className = 'month-header';
    
    const leftHeader = document.createElement('div');
    leftHeader.style.display = 'flex';
    leftHeader.style.alignItems = 'center';
    leftHeader.style.flex = '1';
    
    const nameDiv = document.createElement('div');
    nameDiv.className = 'month-name';
    nameDiv.textContent = label;
    if(isCurrent){
      const badge = document.createElement('span');
      badge.className = 'badge';
      badge.textContent = 'ТЕКУЩИЙ';
      nameDiv.appendChild(badge);
    }
    
    // Кнопка сворачивания/разворачивания
    const toggleBtn = document.createElement('button');
    toggleBtn.className = 'month-toggle-btn' + (isCollapsed ? ' collapsed' : '');
    toggleBtn.innerHTML = '▼';
    toggleBtn.title = isCollapsed ? 'Развернуть' : 'Свернуть';
    toggleBtn.onclick = (e) => {
      e.stopPropagation();
      toggleMonth(idx);
    };
    
    leftHeader.appendChild(nameDiv);
    leftHeader.appendChild(toggleBtn);

    const rightHeader = document.createElement('div');
    rightHeader.style.display = 'flex';
    rightHeader.style.alignItems = 'center';
    
    const addBtn = document.createElement('button');
    addBtn.className = 'btn accent icon small';
    addBtn.innerHTML = '+';
    addBtn.title = 'Добавить расход';
    addBtn.onclick = (e) => {
      e.stopPropagation();
      // Разворачиваем месяц при добавлении расхода
      if (state.collapsedMonths[monthId]) {
        toggleMonth(idx);
      }
      openAddExpenseModal(idx, label);
    };
    
    rightHeader.appendChild(addBtn);

    header.appendChild(leftHeader);
    header.appendChild(rightHeader);
    monthDiv.appendChild(header);

    // Контент месяца (скрывается при сворачивании)
    const monthContent = document.createElement('div');
    monthContent.className = 'month-content';
    
    // Добавляем обработчик клика для открытия детального просмотра
    monthContent.onclick = () => openMonthDetailModal(idx, label, dynamicLimit, monthTotal, mandatoryForMonth);
    monthContent.style.cursor = 'pointer';

    // Stats
    const stats = document.createElement('div');
    stats.className = 'month-stats';

    // Определяем какой план показывать
    let planLabel = 'План';
    let lastMonthWithExpenses = -1;
    for(let i = 0; i < monthlyActuals.length; i++){
      if(monthlyActuals[i] > 0) lastMonthWithExpenses = i;
    }
    
    if(idx === 0 && monthlyActuals[0] === 0){
      planLabel = 'План (базовый)';
    } else if(idx <= lastMonthWithExpenses){
      planLabel = 'План (базовый)';
    } else if(lastMonthWithExpenses >= 0){
      planLabel = 'План (перерасчет)';
    } else {
      planLabel = 'План (базовый)';
    }
    const statPlanned = createStatItem(planLabel, fmt0(dynamicLimit));
    if(isNegativeLimit) statPlanned.style.color = '#ff4444';
    
    const statMandatory = createStatItem('Обязательные', fmt0(mandatoryForMonth));
    const statActual = createStatItem('Потрачено', fmt0(monthTotal));
    if(isOverspent) statActual.style.color = '#ff4444';

    stats.appendChild(statPlanned);
    stats.appendChild(statMandatory);
    stats.appendChild(statActual);

    monthContent.appendChild(stats);
    
    // Добавляем блок со средней тратой за день для текущего месяца - НОВАЯ ВЕРСИЯ
    if(isCurrent && dailyAverage && dailyAverage.days > 0){
      const dailyAvgDiv = document.createElement('div');
      
      // Определяем класс стиля в зависимости от статуса
      let bgClass = 'daily-avg-normal';
      if(dailyAverage.status === 'good') bgClass = 'daily-avg-good';
      else if(dailyAverage.status === 'bad') bgClass = 'daily-avg-bad';
      
      dailyAvgDiv.className = bgClass;
      dailyAvgDiv.style.cssText = 'border-radius:8px; padding:10px; margin:10px 0; border: 1px solid;';
      
      // Определяем цвет для значений
      let valueClass = 'daily-avg-value';
      if(dailyAverage.status === 'good') valueClass += ' good';
      else if(dailyAverage.status === 'bad') valueClass += ' bad';
      
      // Формируем индикатор прогресса
      let progressClass = 'progress-indicator normal';
      let progressText = Math.round(dailyAverage.percentage) + '%';
      if(dailyAverage.status === 'good') {
        progressClass = 'progress-indicator good';
        progressText = '✓ ' + progressText;
      } else if(dailyAverage.status === 'bad') {
        progressClass = 'progress-indicator bad';
        progressText = '⚠ ' + progressText;
      }
      
      dailyAvgDiv.innerHTML = `
        <div style="display:flex; justify-content:space-between; align-items:start;">
          <div style="flex: 1;">
            <div style="font-size:12px; color:var(--muted); margin-bottom:4px;">
              Средняя трата в день
              <span class="${progressClass}">${progressText}</span>
            </div>
            <div style="font-size:16px; font-weight:700;" class="${valueClass}">
              ${fmt0(dailyAverage.average)}
              <span style="font-size:13px; font-weight:500; color:var(--muted); margin-left:4px;">
                (рек. ${fmt0(dailyAverage.recommendedDaily)})
              </span>
            </div>
            <div style="font-size:11px; color:var(--muted); margin-top:2px;">
              за ${dailyAverage.days} ${dailyAverage.days === 1 ? 'день' : dailyAverage.days < 5 ? 'дня' : 'дней'}
            </div>
          </div>
          <div style="text-align:right;">
            <div style="font-size:11px; color:var(--muted);">Всего потрачено:</div>
            <div style="font-size:14px; font-weight:600; color:var(--text);">
              ${fmt0(dailyAverage.total)}
            </div>
            <div style="font-size:11px; color:var(--muted); margin-top:2px;">
              рек. ${fmt0(dailyAverage.recommendedTotal)}
            </div>
          </div>
        </div>
      `;
      monthContent.appendChild(dailyAvgDiv);
    }
    
    // Предупреждение если лимит отрицательный
    if(isNegativeLimit){
      const warning = document.createElement('div');
      warning.style.cssText = 'background:rgba(220,38,38,0.2);border:1px solid #dc2626;border-radius:6px;padding:8px;margin:8px 0;font-size:12px;color:#ff8a8a;font-weight:600;';
      warning.textContent = '⚠️ Бюджет исчерпан! Требуется корректировка плана.';
      monthContent.appendChild(warning);
    }
    
    // Предупреждение о перерасходе
    if(isOverspent && !isNegativeLimit){
      const warning = document.createElement('div');
      warning.style.cssText = 'background:rgba(255,138,138,0.1);border:1px solid #ff8a8a;border-radius:6px;padding:8px;margin:8px 0;font-size:12px;color:#ff8a8a;';
      const overspentAmount = monthTotal - dynamicLimit;
      warning.innerHTML = `⚠️ Перерасход: ${fmt0(overspentAmount)}`;
      monthContent.appendChild(warning);
    }

    // Показываем обязательные платежи для этого месяца
    if(mandatoryForMonth > 0){
      const mandatoryInfo = document.createElement('div');
      mandatoryInfo.style.cssText = 'background:#1a1f37;border:1px solid #4338ca;border-radius:6px;padding:8px;margin:8px 0;font-size:12px;';
      
      const paymentsForMonth = [];
      for(const payment of state.mandatoryPayments){
        const paymentDate = new Date(state.start.getFullYear(), state.start.getMonth() + idx, payment.dayOfMonth);
        if(paymentDate >= state.start && paymentDate <= state.end && paymentDate.getMonth() === (state.start.getMonth() + idx) % 12){
          paymentsForMonth.push(`${payment.name}: ${fmt0(payment.amount)} (${payment.dayOfMonth} числа)`);
        }
      }
      
      mandatoryInfo.innerHTML = `<div style="color:var(--purple);font-weight:600;margin-bottom:4px;">Обязательные платежи:</div>${paymentsForMonth.join('<br>')}`;
      monthContent.appendChild(mandatoryInfo);
    }

    // Transactions list
    if(hasTransactions){
      const transList = document.createElement('div');
      transList.className = 'transactions';
      
      transactions.forEach((t, tIdx) => {
        const transDiv = document.createElement('div');
        transDiv.className = 'transaction';
        
        const leftDiv = document.createElement('div');
        leftDiv.innerHTML = `
          <div>${t.description || 'Без описания'}</div>
          <div class="date">${new Date(t.date).toLocaleDateString('ru-RU')}</div>
        `;
        
        const rightDiv = document.createElement('div');
        rightDiv.style.display = 'flex';
        rightDiv.style.gap = '8px';
        rightDiv.style.alignItems = 'center';
        
        const amountSpan = document.createElement('span');
        amountSpan.className = 'amount';
        amountSpan.textContent = fmt0(t.amount);
        
        const delBtn = document.createElement('button');
        delBtn.className = 'btn ghost small';
        delBtn.textContent = '×';
        delBtn.style.padding = '2px 8px';
        delBtn.onclick = (e) => {
          e.stopPropagation();
          deleteTransaction(idx, tIdx);
        };
        
        rightDiv.appendChild(amountSpan);
        rightDiv.appendChild(delBtn);
        
        transDiv.appendChild(leftDiv);
        transDiv.appendChild(rightDiv);
        transList.appendChild(transDiv);
      });
      
      monthContent.appendChild(transList);
    }

    monthDiv.appendChild(monthContent);
    $monthsList.appendChild(monthDiv);
  });
}



    function createStatItem(label, value){
      const div = document.createElement('div');
      div.className = 'stat-item';
      div.innerHTML = `
        <div class="stat-label">${label}</div>
        <div class="stat-value">${value}</div>
      `;
      return div;
    }

    // ===========================
    // МОДАЛЬНЫЕ ОКНА
    // ===========================
    function openAddExpenseModal(monthIndex, monthLabel){
      state.currentModalMonth = monthIndex;
      document.getElementById('modalMonth').value = monthLabel;
      document.getElementById('expenseAmount').value = '';
      document.getElementById('expenseDesc').value = '';
      document.getElementById('addExpenseModal').classList.add('show');
      document.getElementById('expenseAmount').focus();
    }

    function closeModal(){
      document.getElementById('addExpenseModal').classList.remove('show');
      state.currentModalMonth = -1;
    }

    function saveExpense(){
      const amount = parseFloat(document.getElementById('expenseAmount').value.replace(',', '.'));
      const description = document.getElementById('expenseDesc').value.trim();
      
      if(!Number.isFinite(amount) || amount <= 0){
        document.getElementById('expenseAmount').focus();
        return;
      }
      
      if(state.currentModalMonth >= 0 && state.currentModalMonth < state.months){
        if(!state.monthlyTransactions[state.currentModalMonth]){
          state.monthlyTransactions[state.currentModalMonth] = [];
        }
        
        state.monthlyTransactions[state.currentModalMonth].push({
          amount,
          description: description || 'Без описания',
          date: new Date().toISOString()
        });
        
        closeModal();
        recalcAll();
      }
    }

    function openMandatoryModal(){
      document.getElementById('mandatoryName').value = '';
      document.getElementById('mandatoryAmount').value = '';
      document.getElementById('mandatoryDay').value = '';
      document.getElementById('mandatoryModal').classList.add('show');
      document.getElementById('mandatoryName').focus();
    }

    function closeMandatoryModal(){
      document.getElementById('mandatoryModal').classList.remove('show');
    }

    function saveMandatory(){
      const name = document.getElementById('mandatoryName').value.trim();
      const amount = parseFloat(document.getElementById('mandatoryAmount').value.replace(',', '.'));
      const day = parseInt(document.getElementById('mandatoryDay').value);
      
      if(!name){
        document.getElementById('mandatoryName').focus();
        return;
      }
      
      if(!Number.isFinite(amount) || amount <= 0){
        document.getElementById('mandatoryAmount').focus();
        return;
      }
      
      if(!Number.isFinite(day) || day < 1 || day > 31){
        document.getElementById('mandatoryDay').focus();
        return;
      }
      
      state.mandatoryPayments.push({
        name,
        amount,
        dayOfMonth: day
      });
      
      closeMandatoryModal();
      recalcAll();
    }

    function deleteMandatory(index){
      if(confirm('Удалить этот обязательный платеж?')){
        state.mandatoryPayments.splice(index, 1);
        recalcAll();
      }
    }

        // ===========================
    // ДЕТАЛЬНЫЙ ПРОСМОТР МЕСЯЦА
    // ===========================
    function openMonthDetailModal(monthIndex, monthLabel, plannedAmount, actualSpent, mandatoryAmount){
      document.getElementById('monthDetailTitle').textContent = 'Детали: ' + monthLabel;
      
      // Расчёты
      const available = Math.max(0, plannedAmount - actualSpent);
      const spentInPlan = Math.min(actualSpent, plannedAmount);
      const overspent = Math.max(0, actualSpent - plannedAmount);
      const balance = plannedAmount - actualSpent;
      
      // Рассчитываем среднюю трату за день
      const dailyAverage = calculateDailyAverage(monthIndex);
      
      // Обновляем статистику
      document.getElementById('detailPlan').textContent = fmt0(plannedAmount);
      document.getElementById('detailMandatory').textContent = fmt0(mandatoryAmount);
      document.getElementById('detailActual').textContent = fmt0(actualSpent);
      
      const balanceEl = document.getElementById('detailBalance');
      balanceEl.textContent = fmt0(Math.abs(balance));
      balanceEl.className = 'detail-stat-value';
      if(balance < 0){
        balanceEl.classList.add('overspent');
        balanceEl.textContent = '−' + fmt0(Math.abs(balance));
      } else {
        balanceEl.textContent = '+' + fmt0(balance);
      }
      
      // Добавляем среднюю трату в модальное окно, если это текущий месяц
      const detailStatsDiv = document.querySelector('.detail-stats');
      const existingDailyAvg = document.getElementById('dailyAvgStat');
      if(existingDailyAvg) existingDailyAvg.remove();
      
      if(dailyAverage && dailyAverage.days > 0){
        const dailyAvgStat = document.createElement('div');
        dailyAvgStat.id = 'dailyAvgStat';
        dailyAvgStat.className = 'detail-stat';
        dailyAvgStat.style.gridColumn = 'span 2';
        dailyAvgStat.style.background = 'linear-gradient(135deg, rgba(109,211,251,.08), rgba(167,139,250,.08))';
        dailyAvgStat.style.border = '1px solid #4338ca';
        dailyAvgStat.innerHTML = `
          <div class="detail-stat-label">Средняя трата в день (за ${dailyAverage.days} ${dailyAverage.days === 1 ? 'день' : dailyAverage.days < 5 ? 'дня' : 'дней'})</div>
          <div class="detail-stat-value" style="color:var(--accent);">${fmt0(dailyAverage.average)}</div>
        `;
        detailStatsDiv.appendChild(dailyAvgStat);
      }
      
      // Обновляем легенду
      document.getElementById('legendAvailable').textContent = fmt0(available);
      document.getElementById('legendSpent').textContent = fmt0(spentInPlan);
      
      const overspentLegend = document.getElementById('overspentLegend');
      if(overspent > 0){
        overspentLegend.style.display = 'flex';
        document.getElementById('legendOverspent').textContent = fmt0(overspent);
      } else {
        overspentLegend.style.display = 'none';
      }
      
      // Рисуем круговую диаграмму
      drawPieChart(plannedAmount, actualSpent);
      
      // Показываем модальное окно
      document.getElementById('monthDetailModal').classList.add('show');
    }
    
    function closeMonthDetailModal(){
      document.getElementById('monthDetailModal').classList.remove('show');
    }
    
    function drawPieChart(planned, spent){
      const canvas = document.getElementById('pieChart');
      const ctx = canvas.getContext('2d');
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const radius = 100;
      
      // Очищаем canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Вычисляем углы
      const total = Math.max(planned, spent);
      if(total <= 0) return;
      
      const spentInPlan = Math.min(spent, planned);
      const overspent = Math.max(0, spent - planned);
      const available = Math.max(0, planned - spent);
      
      // Начальный угол (сверху)
      let currentAngle = -Math.PI / 2;
      
      // Рисуем доступную часть (зелёный)
      if(available > 0){
        const availableAngle = (available / total) * Math.PI * 2;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + availableAngle);
        ctx.lineTo(centerX, centerY);
        ctx.fillStyle = '#4ade80';
        ctx.fill();
        currentAngle += availableAngle;
      }
      
      // Рисуем потраченную в пределах плана часть (красный)
      if(spentInPlan > 0){
        const spentAngle = (spentInPlan / total) * Math.PI * 2;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + spentAngle);
        ctx.lineTo(centerX, centerY);
        ctx.fillStyle = '#ff8a8a';
        ctx.fill();
        currentAngle += spentAngle;
      }
      
      // Рисуем перерасход (алый)
      if(overspent > 0){
        const overspentAngle = (overspent / total) * Math.PI * 2;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, currentAngle, currentAngle + overspentAngle);
        ctx.lineTo(centerX, centerY);
        ctx.fillStyle = '#ff4444';
        ctx.fill();
      }
      
      // Рисуем белую обводку
      ctx.strokeStyle = '#27305a';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.stroke();
      
      // Добавляем текст в центре
      ctx.fillStyle = '#e8ecff';
      ctx.font = 'bold 14px Inter, system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      
      const percentage = planned > 0 ? Math.round((spent / planned) * 100) : 0;
      ctx.fillText(percentage + '%', centerX, centerY - 10);
      ctx.font = '12px Inter, system-ui, sans-serif';
      ctx.fillStyle = '#8e97b3';
      ctx.fillText('использовано', centerX, centerY + 10);
    }


    function deleteTransaction(monthIndex, transactionIndex){
      if(confirm('Удалить эту трату?')){
        state.monthlyTransactions[monthIndex].splice(transactionIndex, 1);
        recalcAll();
      }
    }

    // ===========================
// УПРАВЛЕНИЕ ВИДИМОСТЬЮ ЛИНИЙ ГРАФИКА
// ===========================
const chartLinesVisibility = {
  plan: true,
  actual: true,
  forecast: true,
  trend: true
};

function toggleChartLine(lineType) {
  chartLinesVisibility[lineType] = !chartLinesVisibility[lineType];
  
  // Обновляем визуальное состояние кнопки
  const button = document.querySelector(`[data-line="${lineType}"]`);
  if (button) {
    button.classList.toggle('active', chartLinesVisibility[lineType]);
  }
  
  // Перерисовываем график
  recalcAll();
}

// ===========================
// ИНТЕРАКТИВНОСТЬ ГРАФИКА
// ===========================
let chartData = {
  labels: [],
  planned: [],
  actual: [],
  forecast: [],
  trend: []
};

function initChartInteractivity() {
  const canvas = document.getElementById('chart');
  const tooltip = document.getElementById('chartTooltip');
  
  canvas.addEventListener('mousemove', (e) => {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    // Определяем индекс месяца по позиции мыши
    const chartWidth = rect.width - 76; // Учитываем отступы
    const monthWidth = chartWidth / (chartData.labels.length - 1);
    const monthIndex = Math.round((x - 60) / monthWidth);
    
    if (monthIndex >= 0 && monthIndex < chartData.labels.length) {
      showTooltip(monthIndex, e.clientX, e.clientY);
    } else {
      hideTooltip();
    }
  });
  
  canvas.addEventListener('mouseleave', () => {
    hideTooltip();
  });
}

function showTooltip(monthIndex, mouseX, mouseY) {
  const tooltip = document.getElementById('chartTooltip');
  const header = document.getElementById('tooltipHeader');
  const content = document.getElementById('tooltipContent');
  
  if (!chartData.labels[monthIndex]) return;
  
  header.textContent = chartData.labels[monthIndex];
  
  let html = '';
  
  // Добавляем данные по каждой линии
  if (chartData.planned[monthIndex] !== undefined && chartLinesVisibility.plan) {
    html += `
      <div class="tooltip-row">
        <div class="tooltip-label">
          <span class="tooltip-dot" style="background: #7aa2ff"></span>
          План
        </div>
        <div class="tooltip-value">${fmt0(chartData.planned[monthIndex])}</div>
      </div>
    `;
  }
  
  if (chartData.actual[monthIndex] !== undefined && chartLinesVisibility.actual) {
    html += `
      <div class="tooltip-row">
        <div class="tooltip-label">
          <span class="tooltip-dot" style="background: #ffb86b"></span>
          Фактический
        </div>
        <div class="tooltip-value">${fmt0(chartData.actual[monthIndex])}</div>
      </div>
    `;
  }
  
  // Индекс для прогнозов
  const forecastIndex = monthIndex - (chartData.actual.length - 1);
  
  if (forecastIndex >= 0 && chartData.forecast[forecastIndex] !== undefined && chartLinesVisibility.forecast) {
    html += `
      <div class="tooltip-row">
        <div class="tooltip-label">
          <span class="tooltip-dot" style="background: #4ade80"></span>
          Равномерный
        </div>
        <div class="tooltip-value">${fmt0(chartData.forecast[forecastIndex])}</div>
      </div>
    `;
  }
  
  if (forecastIndex >= 0 && chartData.trend[forecastIndex] !== undefined && chartLinesVisibility.trend) {
    html += `
      <div class="tooltip-row">
        <div class="tooltip-label">
          <span class="tooltip-dot" style="background: #ff6b6b"></span>
          По истории
        </div>
        <div class="tooltip-value">${fmt0(chartData.trend[forecastIndex])}</div>
      </div>
    `;
  }
  
  content.innerHTML = html;
  
  // Позиционируем tooltip
  const rect = document.getElementById('chartWrap').getBoundingClientRect();
  let left = mouseX - rect.left + 10;
  let top = mouseY - rect.top - 40;
  
  // Проверяем, не выходит ли за границы
  if (left + 200 > rect.width) {
    left = mouseX - rect.left - 200;
  }
  if (top < 0) {
    top = mouseY - rect.top + 20;
  }
  
  tooltip.style.left = left + 'px';
  tooltip.style.top = top + 'px';
  tooltip.classList.add('show');
}

function hideTooltip() {
  document.getElementById('chartTooltip').classList.remove('show');
}

    // ===========================
    // ГРАФИК
    // ===========================
    function drawChart(labels, planned, actual, forecast, trendForecast) {
  const canvas = document.getElementById('chart');
  const ctx = canvas.getContext('2d');
  
  // Устанавливаем размер canvas для Retina дисплеев
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  canvas.width = rect.width * dpr;
  canvas.height = rect.height * dpr;
  ctx.scale(dpr, dpr);
  
  const w = rect.width;
  const h = rect.height;
  
  // Сохраняем данные для интерактивности
  chartData = {
    labels: labels || [],
    planned: planned || [],
    actual: actual || [],
    forecast: forecast || [],
    trend: trendForecast || []
  };
  
  ctx.clearRect(0, 0, w, h);
  
  const padL = 60, padR = 16, padT = 20, padB = 40;
  const gw = w - padL - padR;
  const gh = h - padT - padB;
  
  const ys = []
    .concat(Array.isArray(planned) ? planned : [])
    .concat(Array.isArray(actual) ? actual : [])
    .concat(Array.isArray(forecast) ? forecast : [])
    .concat(Array.isArray(trendForecast) ? trendForecast : [])
    .filter(Number.isFinite);
  
  if (ys.length === 0) {
    drawEnhancedGrid(ctx, padL, padT, gw, gh, 5, 4);
    return;
  }
  
  let yMin = Math.min(...ys), yMax = Math.max(...ys);
  const pad = Math.max(1000, (yMax - yMin) * 0.1);
  yMin -= pad;
  yMax += pad;
  if (yMax === yMin) { yMax += 1; yMin -= 1; }
  
  // Рисуем сетку и оси
  drawEnhancedGrid(ctx, padL, padT, gw, gh, 5, labels.length || 4);
  drawEnhancedYAxis(ctx, padL, padT, gw, gh, yMin, yMax, 5);
  drawEnhancedXAxis(ctx, labels, padL, padT, gw, gh);
  
  const X = (i, totalPoints) => {
    const t = totalPoints === 0 ? 0 : i / totalPoints;
    return padL + t * gw;
  };
  
  const Y = (val) => {
    const t = (val - yMin) / (yMax - yMin);
    return padT + (1 - t) * gh;
  };
  
  // Добавляем градиенты
  const planGradient = ctx.createLinearGradient(0, padT, 0, padT + gh);
  planGradient.addColorStop(0, 'rgba(122, 162, 255, 0.3)');
  planGradient.addColorStop(1, 'rgba(122, 162, 255, 0.0)');
  
  const actualGradient = ctx.createLinearGradient(0, padT, 0, padT + gh);
  actualGradient.addColorStop(0, 'rgba(255, 184, 107, 0.3)');
  actualGradient.addColorStop(1, 'rgba(255, 184, 107, 0.0)');
  
  // План - с заливкой
  if (planned && planned.length && chartLinesVisibility.plan) {
    // Заливка под линией
    ctx.fillStyle = planGradient;
    ctx.beginPath();
    for (let i = 0; i < planned.length; i++) {
      const x = X(i, planned.length - 1), y = Y(planned[i]);
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.lineTo(X(planned.length - 1, planned.length - 1), padT + gh);
    ctx.lineTo(X(0, planned.length - 1), padT + gh);
    ctx.closePath();
    ctx.fill();
    
    // Линия
    ctx.lineWidth = 2.5;
    ctx.strokeStyle = '#7aa2ff';
    ctx.shadowColor = 'rgba(122, 162, 255, 0.5)';
    ctx.shadowBlur = 10;
    ctx.beginPath();
    for (let i = 0; i < planned.length; i++) {
      const x = X(i, planned.length - 1), y = Y(planned[i]);
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.shadowBlur = 0;
  }
  
  // Фактический - с заливкой и точками
  if (actual && actual.length && chartLinesVisibility.actual) {
    // Заливка
    ctx.fillStyle = actualGradient;
    ctx.beginPath();
    for (let i = 0; i < actual.length; i++) {
      const x = X(i, (planned?.length || 1) - 1), y = Y(actual[i]);
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.lineTo(X(actual.length - 1, (planned?.length || 1) - 1), padT + gh);
    ctx.lineTo(X(0, (planned?.length || 1) - 1), padT + gh);
    ctx.closePath();
    ctx.fill();
    
    // Линия
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#ffb86b';
    ctx.shadowColor = 'rgba(255, 184, 107, 0.5)';
    ctx.shadowBlur = 10;
    ctx.beginPath();
    for (let i = 0; i < actual.length; i++) {
      const x = X(i, (planned?.length || 1) - 1), y = Y(actual[i]);
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.shadowBlur = 0;
    
    // Точки с анимацией
    for (let i = 0; i < actual.length; i++) {
      const x = X(i, (planned?.length || 1) - 1), y = Y(actual[i]);
      
      // Внешний круг
      ctx.fillStyle = 'rgba(255, 184, 107, 0.2)';
      ctx.beginPath();
      ctx.arc(x, y, 8, 0, Math.PI * 2);
      ctx.fill();
      
      // Внутренний круг
      ctx.fillStyle = '#ffb86b';
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, Math.PI * 2);
      ctx.fill();
      
      // Белая точка в центре
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.beginPath();
      ctx.arc(x, y, 1.5, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  // Прогноз равномерный
  if (forecast && forecast.length && chartLinesVisibility.forecast) {
    ctx.lineWidth = 2.5;
    ctx.setLineDash([10, 5]);
    ctx.strokeStyle = '#4ade80';
    ctx.shadowColor = 'rgba(74, 222, 128, 0.4)';
    ctx.shadowBlur = 8;
    ctx.beginPath();
    const totalPoints = (planned?.length || 1) - 1;
    const startIndex = (actual?.length || 1) - 1;
    for (let i = 0; i < forecast.length; i++) {
      const x = X(startIndex + i, totalPoints);
      const y = Y(forecast[i]);
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.shadowBlur = 0;
    
    // Точка в конце
    if (forecast.length > 0) {
      const lastX = X(startIndex + forecast.length - 1, totalPoints);
      const lastY = Y(forecast[forecast.length - 1]);
      ctx.fillStyle = '#4ade80';
      ctx.beginPath();
      ctx.arc(lastX, lastY, 4, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  // Прогноз по истории
  if (trendForecast && trendForecast.length > 1 && chartLinesVisibility.trend) {
    ctx.lineWidth = 2.5;
    ctx.setLineDash([5, 5]);
    ctx.strokeStyle = '#ff6b6b';
    ctx.shadowColor = 'rgba(255, 107, 107, 0.4)';
    ctx.shadowBlur = 8;
    ctx.beginPath();
    const totalPoints = (planned?.length || 1) - 1;
    const startIndex = (actual?.length || 1) - 1;
    for (let i = 0; i < trendForecast.length; i++) {
      const x = X(startIndex + i, totalPoints);
      const y = Y(trendForecast[i]);
      if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.shadowBlur = 0;
    
    // Точка в конце
    if (trendForecast.length > 0) {
      const lastX = X(startIndex + trendForecast.length - 1, totalPoints);
      const lastY = Y(trendForecast[trendForecast.length - 1]);
      
      // Мигающая точка для привлечения внимания
      ctx.fillStyle = 'rgba(255, 107, 107, 0.3)';
      ctx.beginPath();
      ctx.arc(lastX, lastY, 8, 0, Math.PI * 2);
      ctx.fill();
      
      ctx.fillStyle = '#ff6b6b';
      ctx.beginPath();
      ctx.arc(lastX, lastY, 4, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  
  // Добавляем линию целевого баланса
  if (state.target !== undefined) {
    const targetY = Y(state.target);
    ctx.strokeStyle = 'rgba(167, 139, 250, 0.5)';
    ctx.lineWidth = 1.5;
    ctx.setLineDash([8, 4]);
    ctx.beginPath();
    ctx.moveTo(padL, targetY);
    ctx.lineTo(padL + gw, targetY);
    ctx.stroke();
    ctx.setLineDash([]);
    
    // Метка
    ctx.fillStyle = 'rgba(167, 139, 250, 0.8)';
    ctx.font = '11px Inter, system-ui, sans-serif';
    ctx.textAlign = 'right';
    ctx.fillText('Цель', padL - 8, targetY + 3);
  }
}

function drawEnhancedGrid(ctx, x, y, w, h, rows, cols) {
  ctx.save();
  
  // Основная сетка
  ctx.strokeStyle = 'rgba(42, 48, 80, 0.3)';
  ctx.lineWidth = 1;
  
  for (let c = 0; c <= cols; c++) {
    const xx = x + (w * c / cols);
    ctx.beginPath();
    ctx.moveTo(xx, y);
    ctx.lineTo(xx, y + h);
    ctx.stroke();
  }
  
  for (let r = 0; r <= rows; r++) {
    const yy = y + (h * r / rows);
    ctx.beginPath();
    ctx.moveTo(x, yy);
    ctx.lineTo(x + w, yy);
    ctx.stroke();
  }
  
  // Дополнительная мелкая сетка
  ctx.strokeStyle = 'rgba(42, 48, 80, 0.1)';
  ctx.lineWidth = 0.5;
  
  for (let c = 0; c < cols * 2; c++) {
    const xx = x + (w * c / (cols * 2));
    if (c % 2 !== 0) {
      ctx.beginPath();
      ctx.moveTo(xx, y);
      ctx.lineTo(xx, y + h);
      ctx.stroke();
    }
  }
  
  ctx.restore();
}

function drawEnhancedYAxis(ctx, x, y, w, h, vmin, vmax, rows) {
  ctx.save();
  ctx.fillStyle = '#8e97b3';
  ctx.font = '12px Inter, system-ui, sans-serif';
  ctx.textAlign = 'right';
  ctx.textBaseline = 'middle';
  
  for (let r = 0; r <= rows; r++) {
    const t = r / rows;
    const yy = y + (h * t);
    const val = vmax - (vmax - vmin) * t;
    const label = fmtShort(val) + ' ₽';
    
    // Фон для текста
    ctx.fillStyle = 'rgba(15, 18, 32, 0.8)';
    ctx.fillRect(x - 55, yy - 8, 50, 16);
    
    // Текст
    ctx.fillStyle = '#8e97b3';
    ctx.fillText(label, x - 8, yy);
  }
  ctx.restore();
}

function drawEnhancedXAxis(ctx, labels, x, y, w, h) {
  if (!labels || !labels.length) return;
  
  ctx.save();
  ctx.fillStyle = '#8e97b3';
  ctx.font = '11px Inter, system-ui, sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  
  const total = labels.length - 1;
  for (let i = 0; i < labels.length; i++) {
    const xx = x + (w * (i / total || 0));
    
    // Полное название для каждого второго месяца или если месяцев мало
    if (labels.length <= 6 || i % 2 === 0) {
      const parts = labels[i].split(' ');
      const month = parts[0].slice(0, 3);
      const year = parts[1] ? parts[1].slice(2, 4) : '';
      
      ctx.fillText(month, xx, y + h + 8);
      if (year) {
        ctx.fillStyle = 'rgba(142, 151, 179, 0.6)';
        ctx.fillText(year, xx, y + h + 20);
        ctx.fillStyle = '#8e97b3';
      }
    }
  }
  ctx.restore();
}

    function drawGrid(x, y, w, h, rows, cols){
      ctx.save();
      ctx.strokeStyle = getComputedStyle(document.documentElement).getPropertyValue('--grid').trim();
      ctx.lineWidth = 1;
      ctx.globalAlpha = 0.3;

      for(let c=0;c<=cols;c++){
        const xx = x + (w * c/cols);
        ctx.beginPath();
        ctx.moveTo(xx, y);
        ctx.lineTo(xx, y+h);
        ctx.stroke();
      }
      for(let r=0;r<=rows;r++){
        const yy = y + (h * r/rows);
        ctx.beginPath();
        ctx.moveTo(x, yy);
        ctx.lineTo(x+w, yy);
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawYTicks(x, y, w, h, vmin, vmax, rows){
      ctx.save();
      ctx.fillStyle = '#8e97b3';
      ctx.font = '11px system-ui, sans-serif';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'middle';
      for(let r=0;r<=rows;r++){
        const t = r/rows;
        const yy = y + (h * t);
        const val = vmax - (vmax - vmin)*t;
        const label = fmtShort(val) + ' ₽';
        ctx.fillText(label, x - 8, yy);
      }
      ctx.restore();
    }

    function drawXLabels(labels, x, y, w, h){
      if(!labels || !labels.length) return;
      ctx.save();
      ctx.fillStyle = '#8e97b3';
      ctx.font = '11px system-ui, sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'top';
      const total = labels.length-1;
      for(let i=0;i<labels.length;i++){
        const xx = x + (w * (i/total||0));
        const shortLabel = labels[i].slice(0, 3);
        ctx.fillText(shortLabel, xx, y + h + 8);
      }
      ctx.restore();
    }

    // ===========================
    // ОБРАБОТЧИКИ
    // ===========================
    $calcBtn.addEventListener('click', recalcAll);
    $resetBtn.addEventListener('click', () => {
      $initial.value = '';
      $target.value = '';
      $start.value = '';
      $end.value = '';
      Object.assign(state, {
        initial:0,
        target:0,
        start:null,
        end:null,
        months:0,
        mandatoryPayments:[],
        monthlyTransactions:[],
        labels:[],
        collapsedMonths:{} // Добавьте эту строку
      });
      localStorage.removeItem(STORAGE_KEY);
      recalcAll();
    });

    $start.addEventListener('change', recalcAll);
    $end.addEventListener('change', recalcAll);

    // Закрытие модальных окон по клику вне их
    document.getElementById('addExpenseModal').addEventListener('click', (e) => {
      if(e.target.id === 'addExpenseModal'){
        closeModal();
      }
    });
    
    document.getElementById('mandatoryModal').addEventListener('click', (e) => {
      if(e.target.id === 'mandatoryModal'){
        closeMandatoryModal();
      }
    });

        document.getElementById('monthDetailModal').addEventListener('click', (e) => {
      if(e.target.id === 'monthDetailModal'){
        closeMonthDetailModal();
      }
    });

    document.getElementById('forecastDetailModal').addEventListener('click', (e) => {
  if(e.target.id === 'forecastDetailModal'){
    closeForecastDetailModal();
  }
});


    // Закрытие по Escape
        // Закрытие по Escape
document.addEventListener('keydown', (e) => {
  if(e.key === 'Escape'){
    closeModal();
    closeMandatoryModal();
    closeMonthDetailModal();
    closeForecastDetailModal(); // Добавлена новая строка
  }
});

    // ===========================
    // ИНИЦИАЛИЗАЦИЯ
    // ===========================
    (function init(){
      loadState();
      
      if(state.initial) $initial.value = String(state.initial);
      if(state.target) $target.value = String(state.target);
      if(state.start) $start.valueAsDate = state.start;
      if(state.end) $end.valueAsDate = state.end;

      recalcAll();
  
  // Инициализируем интерактивность графика
  initChartInteractivity();  // <--- ДОБАВЬТЕ ЭТУ СТРОКУ ЗДЕСЬ

  // Демо-данные если пусто
  if(!state.start && !state.end && !$initial.value && !$target.value){
    $initial.value = '150000';
    $target.value = '30000';
    const today = new Date();
    const start = new Date(today.getFullYear(), today.getMonth(), 1);
    const end = new Date(today.getFullYear(), today.getMonth() + 3, 0);
    $start.valueAsDate = start;
    $end.valueAsDate = end;
    
    // Демо обязательные платежи
    state.mandatoryPayments = [
      {name: 'Аренда квартиры', amount: 25000, dayOfMonth: 5},
      {name: 'Интернет', amount: 800, dayOfMonth: 10}
    ];
    
    recalcAll();
  }
})();
  </script>
</body>
</html>



